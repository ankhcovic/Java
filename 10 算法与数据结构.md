# 数据结构

## 树

链表的修改是O(1)，查找是从开始或者后面往前找



### 二叉树

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if (preorder == null || preorder.length == 0) {
            return null;
        }
        Map<Integer, Integer> indexMap = new HashMap<Integer, Integer>();
        int length = preorder.length;
        for (int i = 0; i < length; i++) {
            indexMap.put(inorder[i], i);
        }
        TreeNode root = buildTree(preorder, 0, length - 1, inorder, 0, length - 1, indexMap);
        return root;
    }

    public TreeNode buildTree(int[] preorder, int preorderStart, int preorderEnd, int[] inorder, int inorderStart, int inorderEnd, Map<Integer, Integer> indexMap) {
        if (preorderStart > preorderEnd) {
            return null;
        }
        int rootVal = preorder[preorderStart];
        TreeNode root = new TreeNode(rootVal);
        if (preorderStart == preorderEnd) {
            return root;
        } else {
            int rootIndex = indexMap.get(rootVal);
            int leftNodes = rootIndex - inorderStart, rightNodes = inorderEnd - rootIndex;
            TreeNode leftSubtree = buildTree(preorder, preorderStart + 1, preorderStart + leftNodes, inorder, inorderStart, rootIndex - 1, indexMap);
            TreeNode rightSubtree = buildTree(preorder, preorderEnd - rightNodes + 1, preorderEnd, inorder, rootIndex + 1, inorderEnd, indexMap);
            root.left = leftSubtree;
            root.right = rightSubtree;
            return root;
        }
    }
}
```

#### 二叉搜索树

二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：

- 若任意结点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若任意结点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 任意结点的左、右子树也分别为二叉查找树。
- 没有键值相等的结点（no duplicate nodes）。

因为，一棵由n个结点，随机构造的二叉查找树的高度为lgn，所以顺理成章，一般操作的执行时间为O（lgn）.（至于n个结点的二叉树高度为lgn的证明，可参考算法导论 第12章 二叉查找树 第12.4节）。

但二叉树若退化成了一棵具有n个结点的线性链后，则此些操作最坏情况运行时间为O（n）。后面我们会看到一种基于二叉查找树-红黑树，它通过一些性质使得树相对平衡，使得最终查找、插入、删除的时间复杂度最坏情况下依然为O（lgn）。

#### **二叉平衡树**

- 具有二叉查找树的全部特性。

- 每个节点的左子树和右子树的高度差至多等于1

##### AVL树

为了平衡，记录左右子树的高度差，使用一个int，同时高度差超过1进行旋转操作，严格平衡的二叉树

查询比较快，因为更加严格平衡，为了平衡，调整频次更高，插入和查找慢，数据库用的比较多，因为读的比较多，严格平衡，左右旋操作比较多

查询插入查找都是logn

**当平衡被破坏需要进行左旋和右旋**

**左-左型：**右旋



<img src="C:\Users\94307\OneDrive - zju.edu.cn\learnbm\JAVA\学习笔记\640" alt="图片" style="zoom:50%;" />



把这种倾向于左边的情况称之为 **左-左型**。这个时候，我们就可以对节点9进行**右旋操作**，使它恢复平衡。

<img src="https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIPwiaHdKCGdt0cUOibjOK2w4NLXTIyrBNoIFCOf0e1MyZSFQ1k7VppKtozmBL0yeC8elvZaKGHuTudA/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

**即：顺时针旋转两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子**

<img src="https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIPwiaHdKCGdt0cUOibjOK2w4N2rKS9xHL38mzx4iciaibgnKcuBPoWfrUoSmEeRvsPnTfu3OIvYSogyoJQ/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

节点4和9高度相差大于1。由于是**左孩子的高度较高**，此时是**左-左型**，进行右旋。

<img src="https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIPwiaHdKCGdt0cUOibjOK2w4Nruoy7sjcE9CSoVEiaoHzpgo8czI6w9MMx6qJmn4Gl3uib453vicCoTn1Q/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

**这里要注意，节点4的右孩子成为了节点6的左孩子了**



**右-右型：**左旋

左旋和右旋一样，就是用来解决当大部分节点都偏向右边的时候，通过左旋来还原。例如：

<img src="https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIPwiaHdKCGdt0cUOibjOK2w4N84GtNRU43MicjBlgd75hibKIz0N5bEokTo8CgnSuNGbes3GuArfImWdA/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />



**右-左型** 的情况，单单一次左旋或右旋是不行的，下面我们先说说如何处理这种情况。

<img src="https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIPwiaHdKCGdt0cUOibjOK2w4NDEsgpcYcByKe4jw1iaqsOWXwjajEO4uyqfAx4br8CcTpmFaGrPvciauQ/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

**先对节点10进行右旋把它变成右-右型，然后再进行左旋。**

<img src="https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIPwiaHdKCGdt0cUOibjOK2w4N29WrqibpVvEib8aicNYlhNjdYlibibhSBROvdtxaRSsicyEOQMUvmuCutqOA/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

<img src="https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIPwiaHdKCGdt0cUOibjOK2w4Nd7n5TPJelA2AYH9Sp7a77ibqCWDvVl0oP9HL3juibDvibFtUicia7eibLLmg/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

**对于左-右型的情况和刚才的右-左型相反，需要对它进行一次左旋，再右旋。**

<img src="https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIPwiaHdKCGdt0cUOibjOK2w4NiclPNwYybopP8pgAx3vA2rshl0WqyOcWwTT8uDJ9jxrONgTXEXiaxukg/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

##### 红黑树

近似平衡的二叉查找树，额外空间存储的是颜色，是用一个二进制位，更节省空间

**弱衡二叉树**（由于是弱平衡，可以看到，在相同的节点情况下，AVL树的高度低于红黑树），相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，我们就用红黑树。****

插入和删除比较快，调整频次低 hashmap

红黑树，本质上来说就是一棵**二叉查找树**，但它在二叉查找树的基础上**增加了着色和相关的性质使得红黑树相对平衡**，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。

但它是如何保证一棵n个结点的红黑树的高度始终保持在h = logn的呢？这就引出了红黑树的5条性质：

```
1）每个结点要么是红的，要么是黑的。  
2）根结点是黑的。  
3）每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。  
4）如果一个结点是红的，那么它的俩个儿子都是黑的。  
5）对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。  
```

正是红黑树的这5条性质，使得一棵n个结点是红黑树始终保持了logn的高度，从而也就解释了上面我们所说的“红黑树的查找、插入、删除的时间复杂度最坏为O(logn)”这一结论的原因。

### **B树**

因为内存的易失性。一般情况下，我们都会选择将user表中的数据和索引存储在磁盘这种外围设备中。

但是和内存相比，从磁盘中读取数据的速度会慢上百倍千倍甚至万倍，所以，我们应当尽量**减少从磁盘中读取数据的次数。** **另外，从磁盘中读取数据时，都是按照磁盘块来读取的，并不是一条一条的读。** 

如果我们能把尽量多的数据放进磁盘块中，那一次磁盘读取操作就会读取更多数据，那我们查找数据的时间也会大幅度降低。 

如果我们用树这种数据结构作为索引的数据结构，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块，我们都知道平衡二叉树可是每个节点只存储一个键值和数据的。

那说明什么？

说明每个磁盘块仅仅存储一个键值和数据！

那如果我们要存储海量的数据呢？

可以想象到二叉树的节点将会非常多，高度也会及其高，我们查找数据时也会进行很多次磁盘IO，我们查找数据的效率将会极低！

![image-20210324201613905](C:\Users\94307\OneDrive - zju.edu.cn\learnbm\JAVA\学习笔记\image-20210324201613905.png)

为了解决平衡二叉树的这个弊端，我们应该寻找一种单个节点可以存储多个键值和数据的平衡树。也就是我们接下来要说的B树。 

B树（Balance Tree）即为平衡树的意思，下图即是一颗B树。

![image-20210324201625138](C:\Users\94307\OneDrive - zju.edu.cn\learnbm\JAVA\学习笔记\image-20210324201625138.png)

图中的p节点为指向子节点的指针，二叉查找树和平衡二叉树其实也有，因为图的美观性，被省略了。- 图中的每个节点称为页，页就是我们上面说的磁盘块，在mysql中数据读取的基本单位都是页，所以我们这里叫做页更符合mysql中索引的底层数据结构。

从上图可以看出，**B树相对于平衡二叉树，每个节点存储了更多的键值(key)和数据(data)，并且每个节点拥有更多的子节点，子节点的个数一般称为阶，上述图中的B树为3阶B树，高度也会很低。** 

基于这个特性，B树查找数据读取磁盘的次数将会很少，数据的查找效率也会比平衡二叉树高很多。 

假如我们要查找id=28的用户信息，那么我们在上图B树中查找的流程如下： 

- 先找到根节点也就是页1，判断28在键值17和35之间，我们那么我们根据页1中的指针p2找到页3。 
- 将28和页3中的键值相比较，28在26和30之间，我们根据页3中的指针p2找到页8。 
- 将28和页8中的键值相比较，发现有匹配的键值28，键值28对应的用户信息为(28,bv)。

### **B+树**

B+树是对B树的进一步优化。让我们先来看下B+树的结构图：

![image-20210324201717320](C:\Users\94307\OneDrive - zju.edu.cn\learnbm\JAVA\学习笔记\image-20210324201717320.png)

￼根据上图我们来看下B+树和B树有什么不同。 

1. B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。之所以这么做是因为在数据库中页的大小是固定的，innodb中页的默认大小是16KB。如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。

另外，B+树的阶数是等于键值的数量的，如果我们的B+树一个节点可以存储1000个键值，那么3层B+树可以存储1000×1000×1000=10亿个数据。一般根节点是常驻内存的，所以一般我们查找10亿数据，只需要2次磁盘IO。 

2. 因为B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而B树因为数据分散在各个节点，要实现这一点是很不容易的。  

有心的读者可能还发现上图B+树中各个页之间是通过双向链表连接的，叶子节点中的数据是通过单向链表连接的。

其实上面的B树我们也可以对各个节点加上链表。其实这些不是它们之前的区别，是因为在mysql的innodb存储引擎中，索引就是这样存储的。也就是**说上图中的B+树索引就是innodb中B+树索引真正的实现方式，准确的说应该是聚集索引（聚集索引和非聚集索引下面会讲到）。**

通过上图可以看到，在innodb中，我们通过数据页之间通过双向链表连接以及叶子节点中数据之间通过单向链表连接的方式可以找到表中所有的数据。

MyISAM中的B+树索引实现与innodb中的略有不同。在MyISAM中，B+树索引的叶子节点并不存储数据，而是存储数据的文件地址。



# 算法

## 大数

在定义初始值得时候，如果是定义最小值可以定义为Integer.MAX_VALUE，最大值Integer.MIN_VALUE

## 递归

所谓递归，就是会在函数内部代码中，调用这个函数本身

### 三要素

- 功能
- 递归结束条件：需要找出**当参数为啥时，递归结束，之后直接把结果返回**，必须能根据这个参数的值，能够**直接**知道函数的结果是什么。
- 找出函数的等价关系式：**不断缩小参数的范围**，缩小之后，我们可以通过一些辅助的变量或者操作，使原函数的结果不变

### 优化思路

- 考虑是否重复计算，用hashmap或者hashset剪枝
- 考虑是否可以自下而上（递推）

### 递归代码要警惕堆栈溢出

函数调用会使用栈来保存临时变量。每调用一个函数，都会将**临时变量封装为栈帧压入内存栈**，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。可以用一个变量设置做多递归多少次，超过一定次数自己抛出异常

## 循环

* 自下而上

  

## 排序

排序数组的查找问题可以通过二分法来实现

### 顺序查找

O(n)

###二分查找

O(logn)

**题型一：在数组中查找符合条件的元素的下标**
一般而言这个数组是有序的，也可能是半有序的（旋转有序数组或者山脉数组）。

```
-704. 二分查找（简单）	二分查找的最原始问题，使用本题解介绍的方法就要注意，需要后处理。
-34. 在排序数组中查找元素的第一个和最后一个位置（中等）	查找边界问题，题解（有视频讲解）。
-33. 搜索旋转排序数组（中等）	题解，利用局部单调性，逐步缩小搜索区间（其它问题类似）。
81. 搜索旋转排序数组 II（中等）	题解
153. 寻找旋转排序数组中的最小值（中等）	题解
154. 寻找旋转排序数组中的最小值 II（中等）	题解
300. 最长上升子序列（中等）	特别经典的一道「动态规划」，二分查找的思路是基于「动态规划」的状态定义得到，代码很像第 35 题，题解。
275. H指数 II（中等）	题解 ，这个问题题目描述比较让人迷惑，可以跳过不做
852. 山脉数组的峰顶索引（简单）	利用局部单调性，逐步缩小搜索区间。
1095. 山脉数组中查找目标值（中等）	官方题解（有视频讲解），题解
4. 寻找两个有序数组的中位数（困难）	官方题解（有视频讲解），题解
658. 找到 K 个最接近的元素（中等）	题解，这个问题二分的写法需要做复杂的分类讨论，可以放在以后做。
```

**题型二：在一个有范围的区间里搜索一个整数**
定位一个有范围的整数，这件事情也叫「二分答案」或者叫「二分结果」。如果题目要求的是一个整数，这个整数有明确的范围，可以考虑使用二分查找。

```
69. 平方根（简单）	题解，在一个整数范围里查找一个整数，也是二分查找法的应用场景。
287. 寻找重复数（中等）	题解，在一个整数范围里查找一个整数。这个问题二分查找的解法很反常规，知道即可。
374. 猜数字大小（简单）	题解
1300. 转变数组后最接近目标值的数组和	题解
```


**题型三：复杂的二分查找问题（判别条件需要遍历数组）**
「力扣」上还有这样一类问题：目标变量和另一个变量有相关关系（一般而言是线性关系），目标变量的性质不好推测，但是另一个变量的性质相对容易推测（满足某种意义上的单调性）。这样的问题的判别函数通常会写成一个函数的形式。

这一类问题可以统称为「 最大值极小化 」问题，最原始的问题场景是木棍切割问题，这道题的原始问题是「力扣」第 410 题。

解题的思路是这样的：

分析出题目要我们找一个整数，这个整数有范围，所以可以用二分查找；
分析出单调性，一般来说是一个变量 a 的值大了，另一个变量 b 的值就变小，而「另一个变量的值」 b 有限制，因此可以通过调整 a 的值达到控制 b 的效果；
这一类问题的题目条件一定会给出 连续、正整数 这样的关键字，如果没有，问题场景也一定蕴含了这两个关键信息。
以下给出的问题无一例外。

```
410. 分割数组的最大值（困难）	题解
875. 爱吃香蕉的珂珂（中等）	题解
LCP 12. 小张刷题计划（中等）	（题解在第 410 题题解里）
1482. 制作 m 束花所需的最少天数（中等）	（题解在第 1300 题题解里）
1552. 两球之间的磁力（中等）	
```



### 二叉树查找

- 平均时间复杂度：O*(log*n)
- 最差时间复杂度：O(n)
- 空间复杂度：O(1)

## 查找

### 插入排序



### 冒泡排序

### 

### 归并排序(merge sort)

归并排序（MERGE-SORT）是利用**归并**的思想实现的排序方法，该算法采用经典的**分治**（divide-and-conquer）策略（分治法将问题**分**(divide)成一些小的问题然后递归求解，而**治(conquer)**的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。

![img](C:\Users\94307\OneDrive - zju.edu.cn\learnbm\JAVA\学习笔记\1024555-20161218163120151-452283750.png)

​		可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。**分**阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。

**合并相邻有序子序列**

　　再来看看**治**阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。

![img](C:\Users\94307\OneDrive - zju.edu.cn\learnbm\JAVA\学习笔记\1024555-20161218194508761-468169540.png)

![img](C:\Users\94307\OneDrive - zju.edu.cn\learnbm\JAVA\学习笔记\1024555-20161218194621308-588010220.png)

```java
	public static void sort(int[] arr){
        int[] temp = new int[arr.length];// 在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间
        sort(arr, 0, arr.length - 1, temp);
    }

    private static void sort(int[] arr, int left, int right, int [] temp){
        if(left < right){
            int mid  = (left + right) / 2;
            sort(arr, left, mid, temp);// 左边归并排序，使得左子序列有序
            sort(arr, mid + 1, right, temp);// 右边归并排序，使得右子序列有序
            merge(arr, left, mid ,right, temp);// 将两个有序子数组合并操作
        }
    }
    private static void merge(int[] arr, int left, int mid, int right, int[] temp){
        int i = left;// 左序列指针
        int j = mid + 1;// 右序列指针
        int t = 0;// 临时数组指针
        while (i  <= mid && j <= right){
            if (arr[i] <= arr[j]){
                temp[t++] = arr[i++];
            } else{
                temp[t++] = arr[j++];
            }
        }
        while (i <= mid){// 将左边剩余元素填充进temp中
            temp[t++] = arr[i++];
        }
        while (j <= right){// 将右序列剩余元素填充进temp中
            temp[t++] = arr[j++];
        }
        t = 0;
        while (left <= right){// 将temp中的元素全部拷贝到原数组中
            arr[left++] = temp[t++];
        }
    }
```

时间复杂度O(nlogn)

空间复杂度O(n)：新开辟数组O(n) 递归栈空间O(logn)

​	归并排序是稳定排序，它也是一种十分高效的排序，能利用完全二叉树特性的排序一般性能都不会太差。java中Arrays.sort()采用了一种名为**TimSort**的排序算法，就是归并排序的优化版本。从上文的图中可看出，每次合并操作的平均时间复杂度为O(n)，而完全二叉树的深度为|log2n|。总的平均时间复杂度为O(nlogn)。而且，归并排序的最好，最坏，平均时间复杂度均为O(nlogn)。

### 快速排序(quick sort)partition

实现快速排序符法的关键在于先在数组中选择一个数字，接下来把数组中的数字分为两部分， 比选择的数字小的数字移到数组的左边， 比选择的数字大的数字移到数组的右边。这个函数可以如下实现：

```java
private void quickSort(int[] arr, int l, int r){// 递归终止的条件是数组只有一个元素，也就是l>=r
	if(l >= r)  return;// 设置用于遍历数组的头尾双指针
    int i = l, j = r;// 遍历的终止条件是i >= j
    while(i < j){// 寻找右数组小于哨兵arr[l]的元素
        while(i < j && arr[j] >= arr[l]) j--;// 寻找左数组大于哨兵arr[l]的元素
        while(i < j && arr[i] <= arr[l]) i++;// 交换找到的这两个数并进行交换
        swap(arr, i, j);
    }
    swap(arr, i, l);// 对哨兵和左数组中最右边的元素进行交换并进行下一轮递归
	quickSort(arr, l, i - 1);// 左数组是l~i-1，右数组是i+1~r
    quickSort(arr, i + 1, r);
}

private void swap(int[] arr, int a, int b){// 实现数组元素位置交换的元素
    int tmp = arr[a];
    arr[a] = arr[b];
    arr[b] = tmp;
}
```

时间复杂度：O(NlogN)，这里 N 是数组的长度；
空间复杂度：O(logN)，这里占用的空间主要来自递归函数的栈空间。

### 单调栈

```
序号	题目	                        题解
1	 42.  接雨水（困难）			  暴力解法、优化、双指针、单调栈
2	 739. 每日温度（中等）			 暴力解法 + 单调栈
3	 496. 下一个更大元素 I（简单）	   暴力解法、单调栈
4	 316. 去除重复字母（困难）	    栈 + 哨兵技巧（Java、C++、Python）
5	 901. 股票价格跨度（中等）	   「力扣」第 901 题：股票价格跨度（单调栈）
6	 402. 移掉K位数字	
7	 581. 最短无序连续子数组	
```

​	

## 回溯法：二维数组搜索路径，递归实现/栈模拟递归实现

回溯法非常适合由多个步骤组成的问题，并且每个步骤都有多个选项。

回溯法符法适合用递归实现代码。当我们到达某一个节点时， 尝试所有可能的选项并在满足条件的前提下递归地抵达下一个节点。

* 如果在叶节点的状态不满足约束条件，那么只好回溯到它的上一个节点再尝试其他的选项。
* 如果上一个节点所有可能的选项都已经试过， 并且不能到达满足约束条件的终结状态，则再次回溯到上一个节点。
* 如果所有节点的所有选项都已经尝试过仍然不能到达满足约束条件的终结状态， 则该问题无解。

**回溯算法的框架：**

```python
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

## 贪婪算法：分解子问题特殊的选择，证明贪婪选择能够获得最优解

贪心选择：不需要「递归地」计算出所有选择的具体结果然后比较求最值，而只需要做出那个最有「潜力」，看起来最优的选择即可。

## 位运算：与、或、异或、左移和右移5 种位运算

## 分治法

即“ 分而治之“ ，采用的就是各个击破的思想。

我们把分解之后的小问题各个解决，然后把小问题的解决方案结合起来解决大问题。

分治法通常通过递归的方式解决

## 深度优先搜索（DFS）

DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。

### 二叉树的 DFS 

有两个要素：「**访问相邻结点**」和「**判断 base case**」。

```java
// 树的dfs
void traverse(TreeNode root) {
    // 判断 base case
    if (root == null) {
        return;
    }
    // 访问两个相邻结点：左子结点、右子结点
    traverse(root.left);
    traverse(root.right);
}
```

### 网格 DFS 

网格类的题目基本都是使用dfs，每次dfs需要将已经访问的网格变为2，以示区别，然后根据具体的题目要求进行返回或者相应的操作

```java
void dfs(int[][] grid, int r, int c) {
    // 判断 base case
    // 如果坐标 (r, c) 超出了网格范围，直接返回
    if (!inArea(grid, i ,j)) {
        return;
    }
    // 如果这个格子不是岛屿，直接返回
    if (grid[r][c] != 1) {
        return;
    }
    grid[r][c] = 2; // 将访问过的格子标记为「已遍历过」2，可以用来区分海洋格子和已遍历过的陆地格子
    // 访问上、下、左、右四个相邻结点
    dfs(grid, r - 1, c);
    dfs(grid, r + 1, c);
    dfs(grid, r, c - 1);
    dfs(grid, r, c + 1);
}
private boolean inArea(int[][] g, int i, int j){
    return i >= 0 && i < g.length && j >= 0 && j < g[0].length;
}
```

#### [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

```java
class Solution {
    public int numIslands(char[][] grid) {
        int numOfIslands = 0;
        for(int i = 0; i < grid.length; i++){
            for(int j = 0; j < grid[0].length; j++){
                if(grid[i][j] == '1'){
                    numOfIslands += sink(grid, i, j);
                }
                
            }
        } 
        return numOfIslands;
    }
    private int sink(char[][] g, int i, int j){
            if(i < 0 || i == g.length || j < 0 || j == g[i].length){// 越过矩阵边界
                return 0;
            }
            if(g[i][j] != '1'){// 越过岛屿边界或者已经访问过
                return 0;
            }
            g[i][j] = '2';
            sink(g, i - 1, j);// 将相邻的所有1都变为0
            sink(g, i + 1, j);
            sink(g, i, j - 1);
            sink(g, i, j + 1);
            return 1;
        }
}
```

#### [463. 岛屿的周长](https://leetcode-cn.com/problems/island-perimeter/)

<img src="C:\Users\94307\OneDrive - zju.edu.cn\learnbm\JAVA\学习笔记\562d8d63af78af0e3ef2105f065cc96465eec4bf1e8a28b668d6f383f0a1518b.jpg" alt="题目示例" style="zoom:50%;" />

```java
class Solution {
    public int islandPerimeter(int[][] grid) {
        for(int i = 0; i < grid.length; i++){
            for(int j = 0; j < grid[0].length; j++){
                if(grid[i][j] == 1){// 题目中说只有一个岛屿，找到返回即可
                    return sinkdfs(grid, i, j);
                }
                
            }
        }
        return 0;
    }
    private int sinkdfs(int[][] g, int i, int j){
        if(i < 0 || i >= g.length || j < 0 || j >= g[i].length){// 如果到达网格边界，那么就加1
            return 1;
        }
        if(g[i][j] == 0){// 如果到达岛屿边界，那么也加1
            return 1;
        }
        if(g[i][j] != 1){// 如果到达已经访问过的岛屿格子，那么跳过就好
            return 0;
        }
        g[i][j] = 2;// 把已经访问的岛屿格子设置为2
        return sinkdfs(g, i - 1, j) + sinkdfs(g, i + 1, j) + sinkdfs(g, i, j - 1) + sinkdfs(g, i, j + 1);
    }
}
```

#### [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

```java
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int res = 0;
        for(int i = 0; i < grid.length; i++){
            for(int j = 0; j < grid[0].length; j++){
                if(grid[i][j] == 1){
                    res = Math.max(res, sinkdfs(grid, i, j));
                }
            }
        }
        return res;
    }
    private int sinkdfs(int[][] grid , int i, int j){
        if(i < 0 || i >= grid.length || j < 0 || j >= grid[i].length){
            return 0;
        }
        if(grid[i][j] != 1){
            return 0;
        }
        grid[i][j] = 2;// 把已经遍历过的节点设为2
        return 1 + sinkdfs(grid, i - 1, j) + sinkdfs(grid, i + 1, j) + sinkdfs(grid, i, j - 1) + sinkdfs(grid, i, j + 1);
    }
}
```

#### [827. 最大人工岛](https://leetcode-cn.com/problems/making-a-large-island/)

新建一个存放面积的map，从index = 2开始存

首先要dfs找出所有岛屿的面积，将面积存入map中，将每个岛屿网格修改为其在面积map中的索引并且更新最大值

再一次遍历所有海洋网格，新建一个hashset，如果该网格不是在网格边界，其周围的网格是岛屿也就是不为0，，将其保存在hashset中，如果其周围的岛屿网格是来自同一个岛屿，只会被保存一次，由于岛屿网格保存的是其面积在hashmap的索引，所以只要遍历set，将索引对应得面积求和即可得到将当前海洋网格填完后得岛屿面积，每一次遍历海洋网格更新最大值

最后返回最大值即可

```java
class Solution {
    public int largestIsland(int[][] grid) {
        int maxAreaAfterFill = 0;
        int index = 2;// 为了区别0和1，面积数组从下标为2的地方开始存放每个岛屿的面积
        Map<Integer, Integer> map = new HashMap<>();
        for(int i = 0; i < grid.length; i++){
            for(int j = 0; j < grid[0].length; j++){
                if(grid[i][j] == 1){
                    map.put(index, sinkdfs(grid, i, j, index));
                    maxAreaAfterFill = Math.max(maxAreaAfterFill, map.get(index));
                    index++;
                }    
            }
        }
        for(int i = 0; i < grid.length; i++){
            for(int j = 0; j < grid[0].length; j++){
                if(grid[i][j] == 0){
                    maxAreaAfterFill = Math.max(maxAreaAfterFill, changeSea(grid, map, i, j)); 
                }    
            }
        }

        return maxAreaAfterFill;
    }

    private int sinkdfs(int[][] g, int i, int j, int index){// 将每个岛屿网格的内容改为其在面积数组的索引
        if(!inArea(g, i, j)){// 越过网格边界
            return 0;
        }
        if(g[i][j] != 1){// 越过岛屿边界
            return 0;
        }
        g[i][j] = index;
        return 1 + sinkdfs(g, i - 1, j, index) + sinkdfs(g, i + 1, j, index)
                 + sinkdfs(g, i, j - 1, index) + sinkdfs(g, i, j + 1, index);
    }

    private int changeSea(int[][] g, Map<Integer, Integer> map, int i, int j){// 将每个海洋网格内容改为填海后岛屿的面积
        Set<Integer> set = new HashSet<>();
        int seaArea = 1;
        if(inArea(g, i - 1, j) && g[i - 1][j] != 0){
            set.add(g[i - 1][j]);
        }
        if(inArea(g, i + 1, j) && g[i + 1][j] != 0){
            set.add(g[i + 1][j]);
        }
        if(inArea(g, i, j - 1) && g[i][j - 1] != 0){
            set.add(g[i][j - 1]);
        }
        if(inArea(g, i, j + 1) && g[i][j + 1] != 0){
            set.add(g[i][j + 1]);
        }
        for(int index : set){
            seaArea += map.get(index); 
        }
        return seaArea;
    }

    private boolean inArea(int[][] g, int i, int j){
        return i >= 0 && i < g.length && j >= 0 && j < g[0].length;
    }
}
```



## 广度优先搜索（BFS）

​        **两者目标都是遍历整个矩阵，不同点在于搜索顺序不同。

​		**DFS 是朝一个方向走到底，再回退，以此类推；BFS 则是按照“平推”的方式向前搜索。

​		**BFS 实现通常利用队列实现广度优先遍历。

## 动态规划

- 状态

- 状态转移方程，选择

- 初始化

- 输出

- 是否可以优化空间
  - 某个问题的最优解
  - 整体问题的最优解依赖各个子问题的最优解，
  - 小问题之间还有相互重叠的更小的子间题，
  - 从上往下分析问题，从下往上求解间题，

  - 深度优先搜索（DFS）

  - 广度优先搜索（BFS）

### 背包问题

**第一步****要明确两点，「状态」和「选择」**。

先说状态，如何才能描述一个问题局面？只要给定几个可选物品和一个背包的容量限制，就形成了一个背包问题，对不对？**所以状态有两个，就是「背包的容量」和「可选择的物品」**。

再说选择，也很容易想到啊，对于每件物品，你能选择什么？**选择就是「装进背包」或者「不装进背包」嘛**。

明白了状态和选择，动态规划问题基本上就解决了，只要往这个框架套就完事儿了：

```
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 择优(选择1，选择2...)
```

PS：此框架出自历史文章 [团灭 LeetCode 股票买卖问题](http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484508&idx=1&sn=42cae6e7c5ccab1f156a83ea65b00b78&chksm=9bd7fa54aca07342d12ae149dac3dfa76dc42bcdd55df2c71e78f92dedbbcbdb36dec56ac13b&scene=21#wechat_redirect)。

**第二步**要明确`dp`数组的定义。

`dp`数组是什么？其实就是描述问题局面的一个数组。换句话说，我们刚才明确问题有什么「状态」，现在需要用`dp`数组把状态表示出来。

首先看看刚才找到的「状态」，有两个，也就是说我们需要一个二维`dp`数组，一维表示可选择的物品，一维表示背包的容量。

**`dp[i][w]`的定义如下：对于前`i`个物品，当前背包的容量为`w`，这种情况下可以装的最大价值是`dp[i][w]`。**

比如说，如果 dp[3][5] = 6，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。

PS：为什么要这么定义？便于状态转移，或者说这就是套路，记下来就行了。建议看一下我们的动态规划系列文章，几种动规套路都被扒得清清楚楚了。

**根据这个定义，我们想求的最终答案就是****`dp[N][W]`。base case 就是`dp[0][..] = dp[..][0] = 0`**，因为没有物品或者背包没有空间的时候，能装的最大价值就是 0。

细化上面的框架：

```
int dp[N+1][W+1]
dp[0][..] = 0
dp[..][0] = 0

for i in [1..N]:
    for w in [1..W]:
        dp[i][w] = max(
            把物品 i 装进背包,
            不把物品 i 装进背包
        )
return dp[N][W]
```

**第三步****，根据「选择」，思考状态转移的逻辑**。

简单说就是，上面伪码中「把物品`i`装进背包」和「不把物品`i`装进背包」怎么用代码体现出来呢？

**这一步要结合对****`dp`数组的定义和我们的算法逻辑来分析：**

先重申一下刚才我们的`dp`数组的定义：

`dp[i][w]`表示：对于前`i`个物品，当前背包的容量为`w`时，这种情况下可以装下的最大价值是`dp[i][w]`。

**如果你没有把这第****`i`个物品装入背包**，那么很显然，最大价值`dp[i][w]`应该等于`dp[i-1][w]`。你不装嘛，那就继承之前的结果。

**如果你把这第****`i`个物品装入了背包**，那么`dp[i][w]`应该等于`dp[i-1][w-wt[i-1]] + val[i-1]`。

首先，由于`i`是从 1 开始的，所以对`val`和`wt`的取值是`i-1`。

而`dp[i-1][w-wt[i-1]]`也很好理解：你如果想装第`i`个物品，你怎么计算这时候的最大价值？**换句话说，在装第****`i`个物品的前提下，背包能装的最大价值是多少？**

显然，你应该寻求剩余重量`w-wt[i-1]`限制下能装的最大价值，加上第`i`个物品的价值`val[i-1]`，这就是装第`i`个物品的前提下，背包可以装的最大价值。

综上就是两种选择，我们都已经分析完毕，也就是写出来了状态转移方程，可以进一步细化代码：

```
for i in [1..N]:
    for w in [1..W]:
        dp[i][w] = max(
            dp[i-1][w],
            dp[i-1][w - wt[i-1]] + val[i-1]
        )
return dp[N][W]
```

**最后一步****，把伪码翻译成代码，处理一些边界情况**。



## 时间与空间

一般用空间来换时间，而对于一些嵌入式设备则更在乎空间效率









# 算法题

### [剑指 Offer 03. 数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

排序

​		先把输入的数组排序。从排序的数组中找出重复的数字是一件很容易的事情， 只需要从头到尾扫描排序后的数组就可以了。排序一个长度为n 的数组需要O(nlogn) 的时间。 

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        Arrays.sort(nums);
        int repeat = -1;
        for(int i = 1; i < nums.length; i++){
            if(nums[i-1] == nums[i]){
                repeat = nums[i-1];
                break;
            }
        }
        return repeat;
    }
}
```

哈希表

​		从头到尾按顺序扫描数组的每个数字， 每扫描到一个数字的时候，都可以用0(1) 的时间来判断哈希表里是否已经包含了该数字。如果哈希表里还没有这个数字，就把它加入哈希表。如果哈希表里已经存在该数字，就找到一个重复的数字。这个算法的时间复杂度是O(n), 但它提高时间效率是以一个大小为O(n) 的哈希表为代价的。

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        Set<Integer> set = new HashSet<Integer>();
        for(int i = 0; i < nums.length; i++){
            if(set.contains(nums[i])){
                return nums[i];
            }
            set.add(nums[i]);
        }
        return -1;
    }
}
```

原地置换

​		注意到在一个长度为 n 数组中的数字都在O ~ n- 1 的范围内。如果这个数组中没有重复的数字，那么当数组排序之后数字l 将出现在下标为l 的位置。由千数组中有重复的数字， 有些位置可能存在多个数字，同时有些位置可能没有数字。

​		尽管有一个两重循环， 但每个数字最多只要交换两次就能找到属于它自己的位置， 因此总的时间复杂度是O(n) 。另外， 所有的操作步骤都是在输入数组上进行的， 不需要额外分配内存，因此空间复杂度为0(1)

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        if(nums == null || nums.length <= 0){
            return -1;
        }
        for(int i = 0;i < nums.length; i++){
            if(nums[i] < 0 || nums[i] > nums.length){
                return -1;
            }
        }
        
        int temp = 0;
        for(int i = 0; i < nums.length; i++){
            while(nums[i] != i){
                if(nums[i] == nums[nums[i]]){
                    return nums[i];
                }
                else{
                    temp = nums[i];
                    nums[i] = nums[temp];
                    nums[temp] = temp;
                }
            }
        }
        return -1;
    }
}
```

### [剑指 Offer 04. 二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

利用从左到右，从上到下递增的规律，每次选取左上角的元素进行对比，直到找到目标

```java
class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        boolean flag = false;
        // 首先判断数组是否为空以及长度是否为0
        if(matrix != null && matrix.length != 0 && matrix[0].length != 0){
            int row = 0;
            int column = matrix[0].length - 1;
            while(row < matrix.length && column >= 0 ){
                if(matrix[row][column] == target){
                    flag = true;
                    break;
                }
                else if(matrix[row][column] > target){
                    --column;
                }
                else{
                    ++row;
                }
            }
        }

        return flag;
    }
}
```

### [剑指 Offer 05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

请实现一个函数，把字符串 `s` 中的每个空格替换成"%20"。

```java
class Solution {
    public String replaceSpace(String s) {

        if(s == null || s.length() == 0){
            return "";
        }

        // 使用stringBuilder字符串构建器
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < s.length(); i++){
            if(s.charAt(i) == ' '){
                sb.append("%20");
            }
            else{
                sb.append(s.charAt(i));
            }
        }	
		// stringBuilder的toString方法可以得到一个string对象
        return sb.toString();
    }
}
时间复杂度 O(N) ： 遍历使用 O(N)，每轮添加（修改）字符操作使用 O(1) ；
空间复杂度 O(N) ： Java 新建的 StringBuilder 都使用了线性大小的额外空间。
```

```java
class Solution {
    public String replaceSpace(String s) {
        if(s == null || s.length() == 0){
            return "";
        }
		// 新建一个数组
        char[] list = new char[s.length()*3];
        int index = 0;
        for(int i = 0; i < s.length(); i++){
            if(s.charAt(i) == ' '){
                list[index++] = '%';
                list[index++] = '2';
                list[index++] = '0';
            }
            else{
                list[index++] = s.charAt(i);
            } 
        }
        String newStr = new String(list, 0, index);

        return newStr;
    }
}
```

```
或者直接调用api中replace方法
```

### [剑指 Offer 06. 从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public int[] reversePrint(ListNode head) {
       // 利用栈后进先出的思想
       Stack<Integer> st = new Stack<Integer>();
       int lenth = 0;
       // 将每一个结点的数据放入栈内
       while(head != null){
           st.push(head.val);
           head = head.next;
           lenth++;
       }
        // 将结果放入一个数组内，并且依次出栈
       int[] result = new int[lenth];
       for(int i = 0; i < lenth; i++){
           result[i] = st.peek();
           st.pop();
       }

       return result; 
    }
}
```

```java
class Solution {
    public int[] reversePrint(ListNode head) {
       // 创建一个和链表长度相同的数组，但是按照相反的方式存放数据

       // 创建一个临时结点等于头节点，否则在获取链表长度后，head已经指向链表的结尾，导致没有输出
       ListNode tempNode = head;
       int lenth = 0;

       while(tempNode != null){
           lenth++;
           tempNode = tempNode.next;
       }

       int[] result = new int[lenth];

       //需要添加一个索引
       int index = lenth - 1;

       while(head != null){
           result[index--] = head.val;
           head = head.next;
       }

       return result;
    }
}
```

```java
class Solution {
    ArrayList<Integer> tmp = new ArrayList<Integer>();
    public int[] reversePrint(ListNode head) {
        // 递归回溯链表，将链表的数据逆序加入ArrayList中
        recur(head);

        int[] result = new int[tmp.size()];
       // 将数据添加到结果集中
       for(int i = 0; i < tmp.size(); i++){
           result[i] = tmp.get(i);
       }
      
       return result;
    }
    // 利用递归回溯链表
    void recur(ListNode head){
        if(head != null){
            recur(head.next);
            // 由于这里是递归，所以后面的反而先加入链表
            tmp.add(head.val);
        }
        else{
            return;// 直接退出当前方法
        }
    }
}
利用递归回溯链表逆序打印
```

### [剑指 Offer 07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        // 利用树结构天然的递归特性做，即只要分别构造结点，并指定左右结点的值即可，最后返回这一结点，主要时要根据前序遍历和中序遍历找到根节点
        // 首先要判断前序遍历和中序遍历是否为空或者长度为0
        if(preorder == null || preorder.length == 0 || inorder == null || inorder.length == 0){
            return null;
        }
        // new一个根节点
        TreeNode root = new TreeNode(preorder[0]);
        // index表示根节点在中序遍历集合中的索引
        int index = 0;
        for(int i = 0; i < inorder.length; i++){
            if(inorder[i] == root.val){
                index = i;
                break;
            }
        }
        // 使用递归分别构建左右子树 参数分别为前序遍历的数组和中序遍历的数组
        // Arrays.copyOfRange(int[] original, int from, int to)包括-排他
        root.left = buildTree(Arrays.copyOfRange(preorder, 1, index+1), Arrays.copyOfRange(inorder, 0, index));
        root.right = buildTree(Arrays.copyOfRange(preorder, index+1, preorder.length), Arrays.copyOfRange(inorder, index+1, inorder.length));

        return root;
    }
}
```

### [剑指 Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

```java
class CQueue {

    // 实用linkedlist，因为stack已经被淘汰了，它实现了list和deque的接口
    LinkedList<Integer> a, b;

    public CQueue() {
        this.a = new LinkedList<Integer>();
        this.b = new LinkedList<Integer>();

    }
    
    // 添加到队尾，直接添加到栈a的尾部即可
    public void appendTail(int value) {
        a.addLast(value);

    }
    
    // 删除头
    public int deleteHead() {
        // 第一种，b不为空，由于b中元素为a倒序而得，且栈顶元素即为head，所以直接弹出即可
        if(!b.isEmpty()){
            return b.removeLast();
        }

        // 第二种情况，b为空
        else{
            // a不为空时，由于添加到栈a中的元素遵循先进后出，所以需要倒序，用栈b来接收
            if(!a.isEmpty()){
                while(!a.isEmpty()){
                    // 当a为空，则表示倒序已经完成，将b栈顶元素弹出，即完成了删除
                    b.addLast(a.removeLast());
                }
                return b.removeLast();
            }
            // a为空时，ab都为空，没有元素，返回null
            else{
                return -1;
            }
            
        }


    }
}

/**
 * Your CQueue object will be instantiated and called as such:
 * CQueue obj = new CQueue();
 * obj.appendTail(value);
 * int param_2 = obj.deleteHead();
 */
时间复杂度： appendTail()函数为 O(1)；deleteHead() 函数在 NN 次队首元素删除操作中总共需完成 N 个元素的倒序。
空间复杂度 O(N)： 最差情况下，栈 A 和 B 共保存 NN 个元素
```

### [剑指 Offer 10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

```java
第一种解答就是利用递归，循环硬解
	时间复杂度O(n)
	空间复杂度O(1)
    
还有一种是将每次计算的值给保存起来，这样就可以减少计算
    需要一个hashmap，空间复杂度空间复杂度O(n)
    如果是一次计算n，那么需要计算O(n)

   
class Solution {
    public int fib(int n) {
        return fib(n, new HashMap());
    }

    // 将计算过程中产生的结果用集合保存起来，减少重复计算
    public int fib(int n, HashMap<Integer,Integer> map){
        if(n<2){
            return n;
        }
        if(map.containsKey(n)){
            return map.get(n);
        }
        else{
            // 这里要考虑大数，避免int32溢出
            int fib_n_1 = fib(n-1, map) % 1000000007;
            map.put(n-1, fib_n_1);
            int fib_n_2 = fib(n-2, map) % 1000000007;
            map.put(n-2, fib_n_2);
            int fib_n = (fib_n_1 + fib_n_2) % 1000000007;
            map.put(n, fib_n);
            return fib_n;
        }
    }
}
```

###[剑指 Offer 10- II. 青蛙跳台阶问题](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

```java
分析：由于青蛙每次只能跳一级或者两级，考虑最后一步青蛙只可能是跳一级或者两级，所以有f(n)=f(n-1)+f(n-2),这是一个斐波拉契数列，初始条件为f(1)=1,f(2)=2,直接递归
方法一：
class Solution {
    public int numWays(int n) {
        int a = 0;
        int b = 1;
        int temp = 0;
        for(int i = 0; i < n; i++){
            temp = a + b;
            a = b;
            b = temp % 1000000007;
        }
        return b;
    }
}
```

###[剑指 Offer 11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)

​		把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 

```java
可以用二分查找法实现O(logn) 的查找
    
class Solution {
    public int minArray(int[] numbers) {
        // 首先判断数组是否为空或者长度为0
        if(numbers == null || numbers.length <= 0){
            return -1;
        }
        // 定义两个指针，初始时一个指向第一部分数组的头，一个指向第二部分数组的尾
        int index1 = 0;
        int index2 = numbers.length - 1;
        // 中间值初始化为头指针，因为一旦发现旋转数组时顺序排列就可以直接返回头部的值
        int indexMid = index1;
        // 如果不是顺序排列，则需要进行二分查找
        while(numbers[index1] >= numbers[index2]){
            // 查找的终止条件时index2==index1+1
            if(index2 == index1 + 1){
                // 由于中间值只可能在后面数组的第一个值，
                // 所以让中间值等于尾指针指向的值即可，也即返回值
                indexMid = index2;
                break;
            }
            indexMid = (index1 + index2)/2;

            // 如果三个指针相等，那么无法判断中间值属于哪个数组，
            // 无法通过移动指针来查找，只能采用顺序查找
            if(numbers[index1] == numbers[index2]){
                int min = numbers[index1];
                for(int i = index1+1; i < index2; i++){
                    if(numbers[i] < min){
                        min = numbers[i];
                        break;
                    }
                }
                return min;
            } 
            // 中间值比头指针的值大则说明中间值在前半部分的数组中，
            // 最小值只可能在中间值的后面，让头指针指向中间值
            else if(numbers[indexMid] >= numbers[index1]){
                index1 = indexMid;
            } 
            // 中间值比尾指针的值小则说明中间值在后半部分数组中，
            // 最小值只可能在中间值的前面，让尾指针指向中间值
            else if(numbers[indexMid] <= numbers[index2]){
                index2 = indexMid;
            }
        }
        return numbers[indexMid];
    }
}
```

### [剑指 Offer 12. 矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。

[["a","**b**","c","e"],
["s","**f**","**c**","s"],
["a","d","**e**","e"]]

但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。

```
DFS 解析：
递归参数： 
	当前元素在矩阵 board 中的行列索引 i 和 j ，当前目标字符在 word 中的索引 k
	
终止条件：
	返回 false ： 
		(1) 行或列索引越界 或 (2) 当前矩阵元素与目标字符不同 或 (3) 当前矩阵元素已访问过 （ (3) 可合并至 (2) ）
		
	返回 true ：
    	k = len(word) - 1 ，即字符串 word 已全部匹配
    	
递推工作：
	标记当前矩阵元素： 
		将 board[i][j] 修改为 空字符 '' ，代表此元素已访问过，防止之后搜索时重复访问
**空字符（'\0'）做标记是为了防止标记字符与矩阵原有字符重复。当存在重复时，此算法会将矩阵原有字符认作标记字符，从而出现错误

	搜索下一单元格： 
		朝当前元素的 上、下、左、右 四个方向开启下层递归，使用或连接（代表只需找到一条可行路径就直接返回，不再做后续 DFS ），并记录至res
		
	还原当前矩阵元素： 
		将 board[i][j] 元素还原至初始值，即 word[k]
		
	返回值： 
		返回布尔量 res ，代表是否搜索到目标字符串
```

```java
class Solution {
    public boolean exist(char[][] board, String word) {
        
        // 首先将字符串转化为字符数组
        char[] words = word.toCharArray();

        for(int i = 0; i < board.length; i++){
            for(int j = 0; j < board[0].length; j++){
                // 从board[i,j]开始查找
                if(dfs(board, words, i, j, 0)){
                    return true;
                }
            }
        }
        return false;
    }

    // 编写dfs
    boolean dfs(char[][] board, char[] words, int i, int j, int k){
        // 边界判断，如果越界直接返回false
        // 如果字符不等于二维数组中的字符，说明此路不通，返回false
        if(i >= board.length || i < 0 || j >= board[0].length || j < 0 || board[i][j] != words[k]){
            return false;
        }

        // 如果words中每个字符都查完了，返回true
        if(k == words.length - 1){
            return true;
        }

        // 标记当前矩阵元素，将已访问过的元素修改为null，代表已经访问过，防止之后重复搜索
        board[i][j] = '\0';

        // 利用递归，从当前坐标的上下左右四个方向搜索
        boolean res = dfs(board, words, i-1, j, k+1) || dfs(board, words, i+1, j, k+1) 
                        || dfs(board, words, i, j-1, k+1) || dfs(board, words, i, j+1, k+1);

        // 还原当前矩阵元素至初始值即words[k]
        board[i][j] = words[k]; 

        return res;
    }
}

时间复杂度O(3^KMN)：
    最差情况下，需要遍历矩阵中长度为K字符串的所有方案，时间复杂度为O(3^K)；矩阵中共有MN个起点，时间复杂度为O(MN)。
	方案数计算：设字符串长度为K，搜索中每个字符有上、下、左、右四个方向可以选择，舍弃回头（上个字符）的方向，剩下3种选择因此方案数的复杂度为O(3^K)

空间复杂度O(K)：
    搜索过程中的递归深度不超过K，因此系统因函数调用累计使用的栈空间占用O(K)（因为函数返回后，系统调用的栈空间会释放）。最坏情况下 K=MN，递归深度为MN，此时系统栈使用O(MN)的额外空间。
```

### [剑指 Offer 13. 机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

```java
深度优先搜索解析：
     dfs通过递归，先朝一个方向搜到底，再回溯到上个结点，沿另一个方向搜索
    终止条件：越界，数位和超过目标值，已访问过结点

class Solution {
    // 由于后面的dfs需要指导方格的行和列，所以需要定义成员变量，通过this关键字获取m,n,k以及初始化visited
    int m, n, k;
    boolean[][] visited;

    public int movingCount(int m, int n, int k) {
        this.m = m;
        this.n = n;
        this.k = k;
        this.visited = new boolean[m][n];
        // 从(0,0)开始递归，向下和向右开启递归寻找可达解，后面两个是行列各自数位和
        return dfs(0,0,0,0);
    }

    // 编写dfs
    public int dfs(int i, int j, int si, int sj){
        // 越界，为不可达解，当前位置已访问(true)都会直接结束
        if(i >= m || j >= n || k < si + sj || visited[i][j]){
            return 0;
        }
        // 当前位置为可达解，设置为true
        visited[i][j] = true;
        // 向下和向右递归搜索，根据数位和增量公式和三元表达式写出s(i+1)和s(j+1)
        return 1 + dfs(i + 1, j, (i + 1) % 10 != 0 ? si + 1 : si - 8, sj) 
            		+ dfs(i, j + 1, si, (j + 1) % 10 != 0 ? sj + 1 : sj - 8);
    }
}

时间复杂度 O(MN)O(MN) ： 最差情况下，机器人遍历矩阵所有单元格，此时时间复杂度为 O(MN)O(MN) 。
空间复杂度 O(MN)O(MN) ： 最差情况下，Set visited 内存储矩阵所有单元格的索引，使用 O(MN)O(MN) 的额外空间。
```

### [剑指 Offer 14. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)

给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

* 动态规划分析：

​		如果绳子长度为n，则记最优解为f(n)，如果在i处剪一刀，则可以表示为f(n)=f(i)*f(n-i)

​		变成了两个子问题，子问题又可以继续分解，且子问题之间互有重合，所以需要从下到上计算出每个子问题的最优解，用一个数组存放，最后返回f(n)即可

​		需要双重循环，第一个循环为从小到大每个子问题的解，而第二个循环是求解每个子问题的解，里面有递归

```java
class Solution {
    public int cuttingRope(int n) {
        // 由于n<4时均只有一种选择，所以直接将小于4的情况返回
        if(n<2)
            return 0;
        if(n==2)
            return 1;
        if(n==3)
            return 2;
        // 创建一个数组，用于存放每个子问题的解，最后只要返回数组中最后一个元素即可
        int[] ans = new int[n+1];
        ans[0] = 0;
        ans[1] = 1;
        ans[2] = 2;
        ans[3] = 3;

        // 定义一个max用来接收最大值
        int max = 0;
        for(int i = 4; i <= n; i++){
            // 每一个子问题求解结束都需要归0
            max = 0;
            // 里面的循环则是每次到达i的一般即可，再往后就重复了
            for(int j = 0; j <= i/2; j++){
                // 这里一定要先利用三元表达式对max赋值，不然max每次都是0
                max = max > ans[i-j]*ans[j] ? max : ans[i-j]*ans[j];
                ans[i] = max;
            }
        }
        return ans[n];
    }
}
时间复杂度o(n^2)
空间复杂度o(n)
```

* 不等式方法求解

  还可以利用算术几何平均不等式退出最优解，得到按3等分可以得到最优解，并对余数为0，1，2进行讨论

时间复杂度和空间复杂度都是o(1)

```java
class Solution {
    
    public int cuttingRope(int n) {
        if(n <= 3) return n - 1;
        // 尽可能多地剪去长度为3 的绳子段
        int timesOf3 = n / 3;
    
        if(n % 3 == 0){
            return (int)Math.pow(3, timesOf3);
        }
        else if(n % 3 == 1){
            return (int)(Math.pow(3, timesOf3-1)*4);
        }
        else {
            return (int)(Math.pow(3, timesOf3)*2);
        }
    }
}
```



* 贪婪算法求解

  尽可能按照3切分，最后按照2切分

  推论一： 合理的切分方案可以带来更大的乘积

  推论二： 若切分方案合理，绳子段切分的越多，乘积越大
  
  推论三： 为使乘积最大，只有长度为 2 和 3 的绳子不应再切分，且 3 比 2 更优 

```java
class Solution {
    public int cuttingRope(int n) {
        if(n <= 3) return n - 1;
        // 尽可能多地剪去长度为3 的绳子段
        int timesOf3 = n / 3;
        // 当绳子最后剩下的长度为4 的时候， 不能再剪去长度为3 的绳子段
        // 此时更好的方法是把绳子剪成长度力2 的两段， 因为2x2 > 3xl
        if(n - timesOf3*3 == 1)
            timesOf3 -= 1;
        int timesOf2 = (n - timesOf3*3) / 2;
        int max = (int)(Math.pow(3,timesOf3)) * (int)(Math.pow(2,timesOf2));
        return max;
    }
}
```

```java
class Solution {
    public int cuttingRope(int n) {
        if(n <= 3) return n - 1;
        int res = 1;
        while(n > 4){
            n -= 3;
            res *= 3;
        }
        return res * n;
    }
}
```

#### 考虑大数

![image-20210201124853354](C:\Users\94307\AppData\Roaming\Typora\typora-user-images\image-20210201124853354.png)

![image-20210201124918327](C:\Users\94307\AppData\Roaming\Typora\typora-user-images\image-20210201124918327.png)

![image-20210201124936610](C:\Users\94307\AppData\Roaming\Typora\typora-user-images\image-20210201124936610.png)

* 循环求余o(n)+贪心

```java
class Solution {
    public int cuttingRope(int n) {
        if(n <= 3) return n - 1;
        long res = 1;
        int p = 1000000007;
        while(n > 4){
            n -= 3;
            res *= 3;
            res %= p;
        }
        return (int)(res * n % p);
    }
}
```

* 快速幂o(log2n)+不等式

```java
class Solution {
    public static final int p = 1000000007;
    public int cuttingRope(int n) {
        if(n <= 3) return n - 1;
        // 尽可能多地剪去长度为3 的绳子段
        int timesOf3 = n / 3;
    
        if(n % 3 == 0){
            return (int)fastPow(3, timesOf3);
        }
        else if(n % 3 == 1){
            return (int)((fastPow(3, timesOf3-1)*4)%p);
        }
        else {
            return (int)((fastPow(3, timesOf3)*2)%p);
        }
    }

    private long fastPow(long x, int a){
        long res = 1;
        while(a > 0){
            if((a % 2) != 0){
                res = (res * x) % p;
            }
            x = x * x % p;
            a /= 2;
        }
        return res;
    }
}
```

### [剑指 Offer 15. 二进制中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)

请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。

位运算：& | ^ >> << >>>(无符号右移，左边补0)

```java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int count = 0;
        while(n != 0){
            // 最后一位与1&
            if((n & 1) == 1){
                count++;
            }
            // 每次比完右移一位
            n >>>= 1;
        }
        return count;
    }
}

如果是有符号数最后会溢出，陷入死循环，可以通过左移1来判断
    
时间复杂度O(log2n):
	此算法循环内部仅有移位、与、加等基本运算，占用O(1);
	逐位判断需循环log2n次，其中log2n代表数字m最高位1的所在位数(例如log2 4=2,log2 16=4)
空间复杂度O(1):
	变量count使用常数大小额外空间。
```

```java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int count = 0;
        // 循环终止的条件是n!=0不要弄错
        while(n != 0){
            count++;
            // 没找到一个1,与n-1与运算，这样右边的都变为0
            n = n & (n-1);
        }
        return count;
    }
}
时间复杂度O(m):m为1的个数
空间复杂度O(1):变量count使用常数大小额外空间
```

###  [剑指 Offer 16. 数值的整数次方](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)

实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。

```java
class Solution {
    public double myPow(double x, int n) {
        // 考虑等于0的情况
        if(x == 0){
            return 0;
        }
        double product = 1;
        //Java 代码中 int32 变量n∈[−2147483648,2147483647] ，因此当n=−2147483648 时执行n=−n 		会因越界而赋值出错。解决方法是先将 n 存入 long 变量 b ，后面用 b 操作即可
        long b = n;
        // 考虑幂小于0的情况
        if(b < 0){
            x = 1/x;
            b = -b;
        }
        // 快速幂
        while(b > 0){
            // 判断奇偶，如果是奇数，第一步会先乘x
            if((b & 1) == 1){
                product *= x;
            }
            // 快速幂，每次更新x
            x *= x;
            b >>= 1;
        }
        return product;
    }
}

时间复杂度O(log2n) ： 二分的时间复杂度为对数级别。
空间复杂度O(1) ： res, b 等变量占用常数大小额外空间。
```

### [剑指 Offer 17. 打印从1到最大的n位数](https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)

输入数字 `n`，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。

```java
不考虑大数
class Solution {
    public int[] printNumbers(int n) {
        // 最简单的遍历，要求返回 int 类型数组，不考虑大数
        int end = (int)Math.pow(10,n)-1;
        int[] res = new int[end];
        for(int i = 0; i < end; i++){
            res[i] = i + 1;
        }
        return res;
    }
}

时间复杂度O(10^n):生成长度为10^n的列表需要循环O(10^n)
空间复杂度O(1):建立列表需要使用O(1)大小的额外空间，列表作为返回结果，不计入额外空间
```

```java
考虑大数，使用stringbuilder来解决
class Solution {
    int[] res;
    int count = 0, n;
    char[] num, loop = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};
    public int[] printNumbers(int n) {
        this.n = n;
        // 首先定义一个整型数组
        res = new int[(int)Math.pow(10, n) - 1];
        num = new char[n];
        // 去除前面的0，初始值为n-1
        dfs(0);
        return res;
    }
    void dfs(int x) {
        if(x == n) {
            // 取从start开始的字符串
            String s = String.valueOf(num);
            // 将s转化为整数，同时可以去掉0
            int curNum = Integer.parseInt(s);
            // 存入数组，count++使得每次坐标加一
            if(curNum != 0) 
                res[count++] = curNum;
            return;
        }
        for(char i : loop) {
            num[x] = i;
            dfs(x + 1);
        }
    }
}
```

### [剑指 Offer 18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

```java
双指针解决问题，一个pre，一个cur不断移动
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        // 当应删除头结点 head 时，直接返回 head.next 即可
        if(val == head.val){
            return head.next;
        }
        // 初始化双指针
        ListNode pre = head, cur = head.next;
        // ，定位到要删除的结点，当 cur 为空 或 cur 结点值等于 val 时跳出
        while((cur != null) && (cur.val != val)){
            pre = cur;
            cur = cur.next;   
        }
        // 若 cur 指向 null ，代表链表中不包含值为 val 的结点，删除当前结点cur
        if(cur != null){
            pre.next = cur.next;
        }
        // 返回链表头结点
        return head;
    }
}
时间复杂度 O(N) ： N 为链表长度，删除操作平均需循环 N/2 次，最差 N 次
空间复杂度 O(1) ： cur, pre 占用常数大小额外空间
```

### [83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

```java
使用双指针解决问题，先循环遍历每一个结点，找到重复结点则删除后一个结点，如果不是重复结点则继续遍历
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        // 需要考虑输入为空的情况，排除空指针异常
        if(head == null){
            return null;
        }
        // 双指针解决问题
        ListNode pre = head, cur = head.next;
        // 循环遍历每一个结点，循环遍历的终止条件为前后两个指针都不为空，则不会出现空指针的情况
        while((pre != null) && (cur != null)){
            // 如果前后两个结点不相等，移动pre和cur结点
            if(pre.val != cur.val){
                pre = cur;
                cur = cur.next;
            }
            // 如果前后两个结点相等，则删除后面一个结点
            else{
                cur = cur.next;
                pre.next = cur;
            }
        }
        return head;
    }
}
时间复杂度O(n)：需要循环遍历每一个结点，需要O(n)的时间
空间复杂度O(1)：需要pre，cur占用常数大小额外空间
```

### [剑指 Offer 19. 正则表达式匹配](https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/)

请实现一个函数用来匹配包含'. '和'\*'的正则表达式。模式中的字符'.'表示任意一个字符，而'\*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab\*ac*a"匹配，但与"aa.a"和"ab\*a"均不匹配。

```java
动态规划解法
class Solution {
    public boolean isMatch(String s, String p) {
        // 定义状态矩阵的维度
        int m = s.length() + 1, n = p.length() + 1; 
        // 定义布尔型状态转移矩阵
        boolean[][] dp = new boolean[m][n];
        // 空字符匹配为true
        dp[0][0] = true;
        // 初始化首行，避免状态转移时索引越界
        for(int j = 2; j < n; j += 2){
            dp[0][j] = dp[0][j-2] && p.charAt(j - 1) == '*';
        }
        // 状态转移
        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                dp[i][j] = p.charAt(j - 1) == '*' ?
                dp[i][j - 2] || dp[i][j - 1] || dp[i - 1][j] && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.'):
                dp[i - 1][j - 1] && (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.');
            }
        }
        return dp[m - 1][n - 1];
    }
}

时间复杂度 O(MN) ：其中 M, N分别为 s 和 p 的长度，状态转移需遍历整个 dp 矩阵。
空间复杂度 O(MN) ：状态矩阵 dp 使用 O(MN) 的额外空间。
```

### [剑指 Offer 20. 表示数值的字符串](https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/)

请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100"、"5e2"、"-123"、"3.1416"、"-1E-16"、"0123"都表示数值，但"12e"、"1a3.14"、"1.2.3"、"+-5"及"12e+5.4"都不是。

```java
利用正则表达式
class Solution {
    public boolean isNumber(String s) {
        // 用正则表达式求解
        // 首先去除s中头尾的空白字符
        s = s.trim();
        // 排除空串；e前面无数字；只有'.'的情况
        String regex = "(\\s*)|([+-]?\\.?[e|E][\\s\\S]*)|([+-]?\\.)";
        if(s.matches(regex)){
            return false;
        }
        regex = "([+-]?\\d*\\.?\\d*)([e|E][+-]?\\d+)?";
        return s.matches(regex);
    }
}
```

```java
直接遍历
class Solution {
    // 定义索引index来判断遍历每一位
    private int index = 0;
    // 定义一个函数用来判断是否存在无符号整数，也就是0-9
    private boolean scanUnsignedInteger(String str){
        // 定义一个before用来判断是否发生了移位，如果移位则说明有无符号整数
        int before = index;
        // 遍历index之后的整数，终止条件也就是不是这0-9几个数
        while(str.charAt(index) >= '0' && str.charAt(index) <= '9'){
            index++;
        }
        // 返回是否发生移位，移位则说明有
        return index > before;
    }
    // 定义一个函数用来判断是否存在有符号整数，即包含+-
    private boolean scanInteger(String str){
        // 判断里面有无+-
        if(str.charAt(index) == '-' || str.charAt(index) == '+'){
            index++;
        }
        // 处理完正负直接调用判断有无无符号整数的方法
        return scanUnsignedInteger(str);
    }
    public boolean isNumber(String s) {
        // 首先判断是否为空或者长度为0，剔除异常
        if(s == null || s.length() == 0){
            return false;
        }
        // 添加结束标记|
        s = s + '|';
        // 跳过首部的空格
        while(s.charAt(index) == ' '){
            index++;
        }
        // 判断是否包含整数部分
        boolean numeric = scanInteger(s);
        // 判断是否有小数点
        if(s.charAt(index) == '.'){
            index++;
            // 小数点两边只要有一边有数字即可，且右边的必须为无符号整数
            numeric = scanUnsignedInteger(s) || numeric;
        }
        // 判断是否有指数
        if(s.charAt(index) == 'e' || s.charAt(index) == 'E'){
            index++;
            // e的两边都要有数字
            numeric = numeric && scanInteger(s);
        }
        // 跳过尾部空格
        while(s.charAt(index) == ' '){
            index++;
        }
        // 扫描完e后看最后结束的是否为|，如果不是|说明后面还有其他字符，则不是numeric
        return numeric && s.charAt(index) == '|';
    }
}
时间复杂度O(n):s有多长，则要遍历多少位
空间复杂度O(1):index和numeric占用常数大小的额外空间
```

###  [剑指 Offer 21. 调整数组顺序使奇数位于偶数前面](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

```java
引用一个额外数组来存放排序后的数组
class Solution {
    public int[] exchange(int[] nums) {
        // 首先判断数组是否为空或者长度是否为0
        int len = nums.length;
        if(nums == null || len == 0){
            return nums;
        }
        // 定义一个新的数组，用来存放结果
        int[] res = new int[len];
        int before = 0, after = len - 1;
        // 遍历数组，如果为偶数则放到结果数组的尾部，如果为奇数则放到头部
        for(int i = 0; i < len; i++){
            if((nums[i] & 1) == 1){
                res[before++] = nums[i];
            }
            else{
                res[after--] = nums[i];
            }
        }
        return res;
    }
}
时间复杂度O(n):需要遍历n次
空间复杂度O(n):需要引入一个长度为n的数组
```

```java
双指针解决问题，不需要引入额外数组
class Solution {
    public int[] exchange(int[] nums) {
        // 首先判断数组是否为空或者长度是否为0
        int len = nums.length;
        if(nums == null || len == 0){
            return nums;
        }
        // 定义两个指针用来交换
        int before = 0, after = len - 1;
        // 头指针从头部开始，尾指针从尾部开始，遍历的终止条件为头指针大于尾指针
        while(before < after){// 这个判断不可以控制第二层
            // 向后移动直到before指向奇数
            // 第二步和第三步循环过程中，可能遇到 i == j 的边界情况，
            // 此时就应终止，不然 i 就跑到 j 右边了
            while(before < after && (nums[before] & 1) != 0){
                before++;
            }
            // 向后移动直到after指向偶数
            while(before < after && (nums[after] & 1) != 1){
                after--;
            }
            // 交换位置
            int temp = nums[before];
            nums[before] = nums[after];
            nums[after] = temp;
        }
        return nums;
    }
}

时间复杂度O(n):需要遍历n次即数组的长度
空间复杂度O(n):双指针占用常数大小的额外空间
```

### [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。

例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 2 个节点是值为 4 的节点。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        // 链表为空或者k<=0时返回null
        if(head == null || k <= 0){
            return null;
        }
        ListNode p1 = head, p2 = head;
        // 让第一个指针先走k步，期间如果下一个结点不为空则移动指针，若结点为空则返回null
        int i = 0;
        // 第一个结点走k-1步即到达第k个结点,这里排除p1出现空指针异常的情况
        while(i < k - 1){
            if(p1.next != null){
                p1 = p1.next;
            }
            else{
                return null;
            }
            i++;
        }
        while(p1.next != null){
            p1 = p1.next;
            p2 = p2.next;
        }
        return p2;
    }
}

时间复杂度 O(N) ： N 为链表长度；总体看， p1 走了 N 步， p2 走了 (N-k) 步。
空间复杂度 O(1) ： 双指针 p1, p2 使用常数大小的额外空间。
```

### [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

给定一个链表，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回 true 。 否则，返回 false 。

```java
利用hashset不能重复存结点的特点来判断
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        // 首先得判断链表是否为空
        if(head == null){
            return false;
        }
        // 利用hashset来存结点，如果结点已经访问过则hashset一定有，利用hashset不可重复来求解
        Set<ListNode> vistied = new HashSet<ListNode>();
        // 不停的遍历
        while(head.next != null){
            // 如果结点不能存入hashset则说明已经存在，链表存在环
            if(!vistied.add(head)){
                return true;
            }
            head = head.next;
        }
        return false;
    }
}

找到入口结点，只要对原代码稍加修改即可
public class Solution {
    public ListNode detectCycle(ListNode head) {
        // 利用hashset不可重复的特点来寻找
        // 首先处理空链表的情况
        if(head == null){
            return head;
        }
        // 定义一个hashset用来存放结点
        Set<ListNode> visited = new HashSet<ListNode>();
        while(head.next != null){
            // 如果这个结点不能放到hashset中，则这个就是入口结点
            if(!visited.add(head)){
                return head;
            }
            head = head.next;
        }
        return null;
    }
}

时间复杂度：O(N)，其中 N 是链表中的节点数。我们需要遍历每个节点一次。
空间复杂度：O(N)，其中 N 是链表中的节点数。主要为哈希表的开销，我们需要将每个节点插入到哈希表中一次。
```

```java
利用快慢双指针解决问题，如果有环一定会相遇，这里快慢指针分别走几步可以自己定，但是在开始的时候一定得判断初始化的指针是否指向空结点
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */

写法一：
public class Solution {
    public boolean hasCycle(ListNode head) {
        // 首先得判断链表是否为空
        if(head == null){
            return false;
        }
        // 定义快慢双指针，如果存在环，两个指针一定会相遇
        // 快指针每次移动两步，慢指针每次移动一步，分别从一个虚拟头结点开始移动
        ListNode slow = head, fast = head.next;
        // 循环的终止条件是两指针相遇
        while(fast != slow){
            if(fast == null || fast.next == null){
                return false;
            }
            slow = slow.next;
            fast = fast.next.next;
        }
        return true;
    }
}

写法二：
public class Solution {
    public boolean hasCycle(ListNode head) {
        // 首先得判断链表是否为空
        if(head == null){
            return false;
        }
        // 定义快慢双指针，如果存在环，两个指针一定会相遇
        ListNode slow = head, fast = head;
        // 循环的终止条件是两指针相遇
        while(fast != null){
            slow = slow.next;
            if(fast.next != null){
                fast = fast.next.next;
            }else{
                return false;
            }
            if(slow == fast){
                return true;
            }
        }
        return false;
    }
}

写法三
public class Solution {
    public boolean hasCycle(ListNode head) {
        // 首先得判断链表是否为空
        if(head == null){
            return false;
        }
        // 定义快慢双指针，如果存在环，两个指针一定会相遇
        ListNode slow = head, fast = head;
        // 循环的终止条件是两指针相遇
        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
            if(slow == fast){
                return true;
            }
        }
        return false;
    }
}

时间复杂度：O(N)，其中 N 是链表中的节点数。
	当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。
	当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 N 轮。
空间复杂度：O(1)。我们只使用了两个指针的额外空间。
```

* 引入一个额外的指针来寻找入口

```java
写法一：   
public class Solution {
    public ListNode detectCycle(ListNode head) {
        // 利用hashset不可重复的特点来寻找
        // 首先处理空链表的情况
        if(head == null){
            return null;
        }
        // 公式的推导是基于两个指针同时指向头结点的
        ListNode slow = head, fast = head;
        while(fast != null){
            slow = slow.next;
            if(fast.next != null){
                fast = fast.next.next;
            }
            else{
                return null;
            }
            if(fast == slow){
                ListNode p = head;
                while(p != slow){
                    p = p.next;
                    slow = slow.next;
                }
                return p;
            }
        }
        return null;
    }
}

写法二：
public class Solution {
    public ListNode detectCycle(ListNode head) {
        // 利用hashset不可重复的特点来寻找
        // 首先处理空链表的情况
        if(head == null){
            return null;
        }
        // 公式的推导是基于两个指针同时指向头结点的
        ListNode slow = head, fast = head;
        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
            if(fast == slow){
                ListNode p = head;
                while(p != slow){
                    p = p.next;
                    slow = slow.next;
                }
                return p;
            }
        }
        return null;
    }
}

时间复杂度和空间复杂度与判断是否有环是一样的
```



```java
使用双指针
    pre->null
    cur->head
    temp用来存储下一个结点
    循环终止条件为cur==null
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        // 利用双指针解决问题
        ListNode pre = null, cur = head;
        while(cur != null){
            ListNode temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
}
```

### [剑指 Offer 24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        // 利用双指针解决问题
        ListNode pre = null, cur = head;
        while(cur != null){
            ListNode temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
}
时间复杂度 O(N) ： 遍历链表使用线性大小时间。
空间复杂度 O(1) ： 变量 pre 和 cur 使用常数大小额外空间。
```

### [剑指 Offer 25. 合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。

```java
定义一个伪头结点，用一个cur结点去保存新的结点即可
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        // 定义一个伪头结点不能为空结点，否则会空指针异常，用来作为合并后的链表头
        ListNode p = new ListNode(0), cur = p;
        // 开启循环，终止条件为有一个链表已经到达了尾部
        while(l1 != null && l2 != null){
            // 谁小就将谁添加到新链表的尾部
            if(l1.val <= l2.val){
                cur.next = l1;
                l1 = l1.next;
            }else{
                cur.next = l2;
                l2 = l2.next;
            }
            // 添加完，更新新链表的结点
            cur = cur.next;
        }
        // 如果有一个链表已经空了，则cur.next直接指向另外一个链表剩下的结点即可
        cur.next = l1 == null ? l2 : l1;
        return p.next;
    }
}

时间复杂度 O(N) ： 需要遍历的链表长度为l1+l2。
空间复杂度 O(1) ： 指针p和 cur 使用常数大小额外空间。
```

### [剑指 Offer 26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

```java
采用递归法解决问题
    首先判断A的根节点
    	调用函数判断是否正确
    如果没有分别判断左右结点    
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    // 递归法解决
    public boolean isSubStructure(TreeNode A, TreeNode B) {
        // 第一步要边界检查，空树的情况先排除
        if(A == null || B == null){
            return false;
        }
        boolean res = false;
        // 如果根节点相等则判断是否有子结构
        if(A.val == B.val){
            res = doesT1HasT2(A, B);
        }
        // 如果根节点不对，先判断左子树，再判断右子树是否存在，同样采用递归
        if(!res){
            res = isSubStructure(A.left, B);
        }
        if(!res){
            res = isSubStructure(A.right, B);
        }
        return res;
    }

    // 此函数用来判断t1是否有t2的结构
    private boolean doesT1HasT2(TreeNode t1, TreeNode t2){
        if(t2 == null){
            return true;
        }
        if(t1 == null){
            return false;
        }
        // 如果两个树的根结点值不等，则以这两个结点为根节点的树一定没有相同的结构
        // 找到了A中与B根节点值相等的结点才会跳进此函数进行判断，只要return判断B中的所有结点是否在A中都有
        if(t1.val != t2.val){
            return false;
        }
        return doesT1HasT2(t1.left, t2.left) && doesT1HasT2(t1.right, t2.right);
    }
}

时间复杂度O(mn)：m,n分别为AB的结点数量，先序遍历A需要O(m)，递归判断B树所有的结点需要O(n) 
空间复杂度O(m)： 当树 A 和树 B 都退化为链表时，递归调用深度最大。当 M≤N 时，遍历树 A 与递归判断的总递归深度为 M ；当 M>N 时，最差情况为遍历至树 A 叶子节点，此时总递归深度为 M。
```

### [剑指 Offer 27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

请完成一个函数，输入一个二叉树，该函数输出它的镜像。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode mirrorTree(TreeNode root) {
        // 递归解决
        // 边界检查
        if(root == null || root.left == null  && root.right == null){
            return root;
        }
        // 定义一个临时结点
        // 首先交换左右子结点
        TreeNode temp = root.right;
        // 也可以在这里直接递归
        root.right = root.left;
        root.left = temp;
        // 如果左右子树不为空，则对左右子树的左右结点也要交换，采用递归的方法
        if(root.left != null){
            root.left = mirrorTree(root.left);
        }
        if(root.right != null){
           root.right =  mirrorTree(root.right);
        }
        return root;
    }
}
时间复杂度 O(N) ： 其中 N 为二叉树的节点数量，建立二叉树镜像需要遍历树的所有节点，占用 O(N) 时间。
空间复杂度 O(N) ： 最差情况下（当二叉树退化为链表），递归时系统需使用 O(N) 大小的栈空间。
```

### [剑指 Offer 28. 对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)

请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。

```java
递归求解
考虑从顶至底递归，判断每对节点是否对称，从而判断树是否为对称二叉树。
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return isSymmetric(root, root);
    }

    private boolean isSymmetric(TreeNode root1, TreeNode root2) {
        // 如果两个结点都为空，说明对称
        if(root1 == null && root2 == null){
            return true;
        }
        // 如果只有一个结点为空，说明不对称
        if(root1 == null || root2 == null){
            return false;
        }
        // 如果根节点的值都不相等一定不对称
        if(root1.val != root2.val){
            return false;
        }
        // 判断对称的遍历方法得到的遍历序列是否和前序遍历一样，返回即可
        return isSymmetric(root1.left, root2.right) && isSymmetric(root1.right, root2.left);
    }
}

时间复杂度 O(N) ： 其中 N 为二叉树的节点数量，每次执行 recur() 可以判断一对节点是否对称，因此最多调用 N/2 次 recur() 方法。
空间复杂度 O(N) ： 最差情况下（见下图），二叉树退化为链表，系统使用 O(N) 大小的栈空间。
```

###[剑指 Offer 29. 顺时针打印矩阵](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。

```java
考虑设定矩阵的“左、上、右、下”四个边界，模拟以上矩阵遍历顺序
每次都要判断一下是否越界，一越界就终止循环
善用while(true)
    
class Solution {
    public int[] spiralOrder(int[][] matrix) {
        // 判断边界，在定义row和column之前，否则会报空指针异常，这是最先应该做的事情
        if(matrix == null || matrix.length == 0 || matrix[0] == null || matrix[0].length == 0){
            return new int[0];
        }
        // 定义矩阵的行和列，并且定义一个用于循环的参数
        int row = matrix.length, column = matrix[0].length, x = 0;
        int left = 0, right = column - 1, top = 0, bottom = row - 1;
        int[] res = new int[row * column];
        // 循环的终止条件为矩阵的边界条件被破坏
        while(true){
            // 循环的顺序是从左到右，从上到下，从右到左，从下到上
            // 每个方向首先根据边界打印，然后边界向内收缩，最后判断打印是否完毕，如果完毕则break
            for(int i = left; i <= right; i++){
                res[x++] = matrix[top][i];
            }
            if(++top > bottom){
                break;
            }
            for(int i = top; i <= bottom; i++){
                res[x++] = matrix[i][right];
            }
            if(left > --right){
                break;
            }
            for(int i = right; i >= left; i--){
                res[x++] = matrix[bottom][i];
            }
            if(top > --bottom){
                break;
            }
            for(int i = bottom; i >= top; i--){
                res[x++] = matrix[i][left];
            }
            if(++left > right){
                break;
            }
        }
        return res;
    }
}

时间复杂度O(mn)：m,n分别为矩阵的行和列，需要遍历元素个单位时间 
空间复杂度O(1)：上下左右边界指针占用常数个额外空间，结果数组res长度为mn，无论如何都要占用
```

### [剑指 Offer 30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)

定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

```java
思路：构建辅助栈B，保证每一次入栈的时候，将当前min存放到辅助栈，而每次更新的时候则将辅助栈和栈顶元素一起弹出
class MinStack {

    Stack<Integer> A, B;

    /** initialize your data structure here. */
    public MinStack() {
        A = new Stack<Integer>();
        B = new Stack<Integer>();
    }
    
    // push入栈的话直接放到A中，要是比辅助栈B栈顶元素小或者B为空，则入栈
    public void push(int x) {
        A.push(x);
        if(B.empty() || B.peek() >= x){
            B.push(x);
        }
    }
    
    // pop出栈的话直接把A的栈顶元素出栈，要是小于等于B栈顶元素，则弹出B栈顶元素
    public void pop() {
        if(A.pop() <= B.peek()){
            B.pop();
        }
    }
    
    // 返回A栈顶元素
    public int top() {
        return A.peek();
    }
    
    // 返回辅助栈栈顶元素
    public int min() {
        return B.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.min();
 */
时间复杂度 O(1) ： push(), pop(), top(), min() 四个函数的时间复杂度均为常数级别。
空间复杂度 O(N) ： 当共有 N 个待入栈元素时，辅助栈 B 最差情况下存储 N 个元素，使用 O(N) 额外空间
```

### [剑指 Offer 31. 栈的压入、弹出序列](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。

```java
构建辅助栈进行栈模拟，先入后出，模拟成功则可以，不成功则不可以
class Solution {
    public boolean validateStackSequences(int[] pushed, int[] popped) {
        // 其实不用边界判断，如果两个序列都为空，那么最后不会有元素入栈，栈中还是为空
        // 构建辅助栈，将待出栈元素存入辅助栈中，如果最后辅助栈为空则说明满足题意
        Stack<Integer> stack = new Stack<>();
        int i = 0;
        // 遍历入栈序列的每一个元素
        for(int num : pushed){
            // 只要不等于出栈序列中的元素就入栈
            stack.push(num);
            // 循环判断：只要栈不为空或者栈顶元素和出栈序列的当前元素相等，则出栈
            while(!stack.empty() && stack.peek() == popped[i]){
                stack.pop();
                i++;
            }
        }
        return stack.empty();
    }
}

时间复杂度 O(N) ： 其中 N 为列表 pushed 的长度；每个元素最多入栈与出栈一次，即最多共 2N 次出入栈操作。
空间复杂度 O(N) ： 辅助栈 stack 最多同时存储 N 个元素
```

### [剑指 Offer 32 - I. 从上到下打印二叉树](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)

从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。

```java
广度优先搜索(BFS)实现从上到下打印结点，借助队列实现
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int[] levelOrder(TreeNode root) {
        // 如果树为空，则返回一个空的数组
        if(root == null){
            return new int[0];
        }
        // 使用队列的先入先出的特性来实现层序遍历
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        // 使用arraylist创建一个数组，只要把数添加，数组的长度就会自然增长
        ArrayList<Integer> res = new ArrayList<>();
        // 如果队列不为空，每当把队首的结点出队以后，把下一层的结点添加到队尾
        // 队列出一个结点，加两个下层的结点，当前行的结点出队完再出下一层
        while(!queue.isEmpty()){
            // queue中的offer和poll是加入和移除元素，如用collection中的add和remove会报异常
            TreeNode node = queue.poll();
            res.add(node.val);
            if(node.left != null){
                queue.add(node.left);
            }
            if(node.right != null){
                queue.add(node.right);
            }
        }
        int[] list = new int[res.size()];
        for(int i = 0; i < res.size(); i++){
            list[i] = res.get(i);
        }
        return list;
    }
}

时间复杂度 O(N) ：N为二叉树的节点数量，即 BFS 需循环 N 次。
空间复杂度 O(N) ：最差情况下，即当树为平衡二叉树时，最多有 N/2 个树节点同时在 queue 中，使用 O(N)大小的额外空间。
```

### [剑指 Offer 32 - II. 从上到下打印二叉树 II](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。

```java
和之前的做法类似，都是使用一个队列，不过每层在打印结点的时候需要用一个临时数组来接收
    并且需要用到queue.size()来初始化每层遍历的循环变量
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        // 依然是用一个队列来实现，不过每层遍历完得更新队列的长度
        // 如果输入的树为空，返回的是一个空数组
        if(root == null){
            return new ArrayList<>();
        }
        // 定义一个队列用来存储每层的结点
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        // 定义一个数组用来接收最终的结果
        List<List<Integer>> res = new ArrayList<>();
        // 开始逐层遍历
        while(!queue.isEmpty()){
            // 定义一个临时数组，用来接收每一层的结点的值
            List<Integer> tmp = new ArrayList<>();
            // 每层遍历的终止条件是当前层的队列里的结点都已经取完
            // 必须的用之前的queue.size来初始化i，不然每次的队列长度都是变化的
            for(int i = queue.size(); i > 0; i--){
                // 当前结点出列并且将其值添加到tmp中去
                TreeNode node = queue.poll();
                tmp.add(node.val);
                // 如果待移除队列的结点有子结点要将他们添加到队尾
                if(node.left != null) queue.add(node.left);
                if(node.right != null) queue.add(node.right);
            }
            // 将tmp数组添加到结果集中
            res.add(tmp);
        }
        return res;
    }
}
时间复杂度 O(N) ：N为二叉树的节点数量，即 BFS 需循环 N 次。
空间复杂度 O(N) ：最差情况下，即当树为平衡二叉树时，最多有 N/2 个树节点同时在 queue 中，使用 O(N)大小的额外空间。
```

### [剑指 Offer 32 - III. 从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。

```java
使用双端队列进行之字打印
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        // 方法和分行打印结点类似，不过要利用其队列双端都可以进的特点
        // 可以让存放结点的队列两边进，也可以让存放结点值的数组两边进
        // 考虑边界条件
        if(root == null){
            return new ArrayList<>();
        }
        // 定义一个队列用来存放结点
        Queue<TreeNode> queue = new LinkedList<>();
        // 将头节点存放到队列中；
        queue.add(root);
        // 定义一个用来存放结果集的数组
        List<List<Integer>> res = new ArrayList<>();
        // 定义一个标志level，奇数从左往右，偶数从右往左，初始值为0
        // 还可以使用res.size()来判断奇偶性
        int level = 0;
        // 开启层序遍历
        while(!queue.isEmpty()){
            // 定义一个用于存放每层结点的双端队列，链表可以当作双端队列使用，每层保存完都需要初始化
            LinkedList<Integer> tmp = new LinkedList<>();
            // 每遍历完一层，level加1
            level++;
            // 将当前层的结点依次放入队列中
            for(int i = queue.size(); i > 0; i--){
                TreeNode node = queue.poll();
                // 奇数层结点值从左往右存放addlast，偶数层结点值从右往左存放addfirst
                if((level & 1) == 0) tmp.addFirst(node.val); else tmp.addLast(node.val);
                // 下面添加下一层的结点，依据flag奇偶性添加，奇尾偶头
                if(node.left != null){ queue.add(node.left);}
                if(node.right != null){ queue.add(node.right);}
            }
            // 每一层遍历完，将当前层的值存放到结果集res中
            res.add(tmp);
        }
        return res;
    }
}

// 倒序在存放到tmp中进行，利用Collections.reverse将其反转
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        // 方法和分行打印结点类似，不过要利用其队列双端都可以进的特点
        // 可以让存放结点的队列两边进，也可以让存放结点值的数组两边进
        // 考虑边界条件
        if(root == null){
            return new ArrayList<>();
        }
        // 定义一个队列用来存放结点
        Queue<TreeNode> queue = new LinkedList<>();
        // 将头节点存放到队列中；
        queue.add(root);
        // 定义一个用来存放结果集的数组
        List<List<Integer>> res = new ArrayList<>();
        // 开启层序遍历
        while(!queue.isEmpty()){
            // 定义一个用于存放每层结点的双端队列，链表可以当作双端队列使用，每层保存完都需要初始化
            List<Integer> tmp = new ArrayList<>();
            // 将当前层的结点依次放入队列中
            for(int i = queue.size(); i > 0; i--){
                TreeNode node = queue.poll();
                tmp.add(node.val);
                // 下面添加下一层的结点，依据flag奇偶性添加，奇尾偶头
                if(node.left != null){ queue.add(node.left);}
                if(node.right != null){ queue.add(node.right);}
            }
            // 判断奇偶如果为偶数层，则将tmp倒序
            if((res.size() & 1) == 1) Collections.reverse(tmp);
            // 每一层遍历完，将当前层的值存放到结果集res中
            res.add(tmp);
        }
        return res;
    }
}

时间复杂度 O(N) ：N为二叉树的节点数量，即 BFS 需循环 N 次。
空间复杂度 O(N) ：最差情况下，即当树为平衡二叉树时，最多有 N/2 个树节点同时在 queue 中，使用 O(N)大小的额外空间。
```

### [剑指 Offer 33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 `true`，否则返回 `false`。假设输入的数组的任意两个数字都互不相同。

**二叉搜索树定义：** 左子树中所有节点的值 < 根节点的值；右子树中所有节点的值 > 根节点的值；其左、右子树也分别为二叉搜索树。

```java
递归法，先找到左右子树根节点，然后分别递归
class Solution {
    public boolean verifyPostorder(int[] postorder) {
        // 用到一个辅助判断的方法，回溯法
        return recur(postorder, 0, postorder.length - 1);
    }
    boolean recur(int[] postorder, int head, int tail){
        // 数组只有一个元素或者为空
        if(head >= tail){
            return true;
        }
        // 定义左右子树分解点mid
        int mid = head;
        // 定义每次遍历的根节点root
        int root = postorder[tail];
        // 寻找左子树head-mid-1(mid是通过于根节点的比较判断出来的)
        while(postorder[mid] < root){
            mid++;
        }
        // 寻找右子树mid-tail-1(由于判断时会改变mid的值，因此用一个临时变量保存起来)
        // 需要定义一个临时的变量用来辅助判断是否到达右子树的末尾，
        // tail是根节点
        int temp = mid;
        while(temp < tail){
            // 如果右子树有结点的值小于根节点，直接pass
            if(postorder[temp++] < root){
                return false;
            }
        }
        // 对左子树head ~ mid-1递归回溯，对右子树mid ~ tail-1递归回溯
        return recur(postorder, head, mid - 1) && recur(postorder, mid, tail-1);
    }
}

时间复杂度 O(N^2) ： 每次调用recur减去一个根节点，因此递归占用 O(N) ；最差情况下（即当树退化为链表），每轮递归都需遍历树所有节点，占用 O(N) 。
空间复杂度 O(N) ： 最差情况下（即当树退化为链表），递归深度将达到 N 。
```

### [剑指 Offer 34. 二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。

```
先序遍历：按照根左右的顺序遍历二叉树
路径记录：在先序遍历中，记录遍历的路径，当遍历的路径上个结点值之和等于输入的整数时，将该路径保存到结果集中
```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    // 初始化结果列表
    LinkedList<List<Integer>> res = new LinkedList<>();
    // 初始化路径列表，由于回溯时需要从路径列表把当前结点删除
    // 由于在队尾需要用到removelast，所以必须用LinkedList
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        // 根据输入的二叉树递推
        recur(root, sum);
        return res;
    }
    void recur(TreeNode root, int tar){
        // 如果树为空，直接结束，结果集为空
        if(root == null) return;
        // 将当前结点的值添加到path中
        path.add(root.val);
        // 将tar减去当结点的值
        tar -= root.val;
        // 如果tar等于0并且已经到达叶子结点，则将路径保存到结果集中
        if(tar == 0 && root.left == null && root.right == null)
            // 注意这里要复制path并将其保存到结果集中，否则保存的是path对象的引用，后面path改变时，这个结果集也会随之改变
            res.add(new LinkedList(path));
        // 递归左右结点
        recur(root.left, tar);
        recur(root.right, tar);
        // 向上回溯前，需要将当前的结点从path中删除
        path.removeLast();
    }
}
```

```
时间复杂度O(N)：N是二叉树的结点数，先序遍历需要遍历所有结点
空间复杂度O(N)：当二叉树退化为链表时，path中存储所有结点，需要O(N)的额外空间
```

### [剑指 Offer 35. 复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。

```
使用map先保存结点，再复制关系
```

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/
class Solution {
    public Node copyRandomList(Node head) {
        // 边界判断
        if(head == null) 
            return null;
        // 利用一个hashmap保存每个结点
        Node cur = head;
        Map<Node, Node> map = new HashMap<>();
        // 只要cur不为空，就将此结点及其复制保存到map中
        // map的键和值保存的是同一个结点
        while(cur != null){
            map.put(cur, new Node(cur.val));
            // 移动指针
            cur = cur.next;
        }
        // 由于前面的结点所指向的结点可能还没有在map中
        // 只有等map有全部的结点后才能开始保存指向关系
        // 保存完结点，将cur重新指向头节点
        cur = head;
        // 开始复制指向关系
        while(cur != null){
            map.get(cur).next = map.get(cur.next);// 值中表示cur.next的结点
            map.get(cur).random = map.get(cur.random);// 值中表示cur.random的结点
            cur = cur.next;
        }
        // 返回map中第一个键对应的值，map中保存的第一个键就是head
        return map.get(head);
    }
}
```

```
时间复杂度O(N)：N是链表的结点数，两轮遍历链表 
空间复杂度O(N)：哈希表消耗线性大小的额外空间
```

### [剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val,Node _left,Node _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/
class Solution {
    // 需要创建一个头节点以及用于遍历的pre，和cur配合起来使用
    Node pre, head;
    public Node treeToDoublyList(Node root) {
        // 边界判断
        if(root == null)
            return null;
        // 调用中序遍历的递归函数并且在里面完成节点指向的修改
        dfs(root);
        // 在修改完成双向链表的转化后，设置头尾节点的指向
        head.left = pre;
        pre.right = head;
        return head;
    }
    // 中序遍历并且创建指引
    void dfs(Node cur){
        // 如果当前节点为空，直接结束
        if(cur == null)
            return;
        // 先递归遍历左子树
        dfs(cur.left);
        // 创建指向
        // 如果pre不为空，则指向当前节点，否则头节点指向当前节点
        if(pre != null)
            pre.right = cur;
        else
            head = cur;
        cur.left = pre;
        // 修改前驱节点
        pre = cur;
        // 最后递归遍历右子树
        dfs(cur.right);
    }
}
```

```
时间复杂度 O(N) ： N 为二叉树的节点数，中序遍历需要访问所有节点。
空间复杂度 O(N) ： 最差情况下，即树退化为链表时，递归深度达到 N，系统使用 O(N) 栈空间。
```

### [剑指 Offer 37. 序列化二叉树](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/)

请实现两个函数，分别用来序列化和反序列化二叉树。

```
序列化：
	首先利用队列层序遍历二叉树，并将其打印到一个string中，注意判断节点是否为空，如果为空直接添加，如果不是，还要添加它的左右子节点
反序列化：
	首先将序列化结果分解为一个string数组，并创建一个队列用来保存节点，移动指针i，动态创建节点，当前节点如果不为空，就添加左右节点，最后返回根节点
```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        // 利用队列实现对二叉树的层序遍历，从而实现序列化
        // 边界判断
        if(root == null){
            return "[]";
        }
        // 定义一个队列，来完成节点的动态添加，注意linkedlist初始化的方式
        Queue<TreeNode> queue = new LinkedList<>(){{
            add(root);
        }};
        // 用一个StringBuilder来存储二叉树的序列化结果
        StringBuilder res = new StringBuilder("[");
        // 开启遍历
        while(!queue.isEmpty()){
            // 定义一个临时节点，用来保存值到res中
            TreeNode node = queue.poll();
            if(node != null){
                res = res.append(node.val).append(",");
                queue.add(node.left);
                queue.add(node.right);
            } else{
                res = res.append("null").append(",");
            } 
        }
        // 完成层序遍历后删除最后的','，增加一个']'
        res = res.deleteCharAt(res.length() - 1);
        res = res.append("]");
        return res.toString();
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        // 利用队列以及索引之间的关系完成二叉树的重建
        // 如果输入序列为空，那么返回空即可
        if(data.equals("[]"))
            return null;
        // 定义一个list用来存放每个节点的值
        String[] vals = data.substring(1, data.length() - 1).split(",");
        // 定义二叉树的根节点
        TreeNode root = new TreeNode(Integer.parseInt(vals[0]));
        // 定义一个队列用来重建二叉树
        Queue<TreeNode> queue = new LinkedList<>(){{
            add(root);
        }};
        // 定义一个指针i用来选择每次要放入节点的vals值，由于初始化root已经放入queue，所以从1开始
        int i = 1;
        // 开启遍历
        while(!queue.isEmpty()){
            // 节点用完即弹出，
            TreeNode tmp = queue.poll();
            // 添加左节点，将此节点放入队列，以便之后添加它的左右节点
            if(!vals[i].equals("null")){
                tmp.left = new TreeNode(Integer.parseInt(vals[i]));
                queue.add(tmp.left);
            }
            i++;// 每添加一个节点，指针都要往右移动一次
            // 添加右节点
            if(!vals[i].equals("null")){
                tmp.right = new TreeNode(Integer.parseInt(vals[i]));
                queue.add(tmp.right);
            }
            i++;
        }
        return root;
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));
```

```
序列化
时间复杂度 O(N) ： N 为二叉树的节点数，层序遍历需要访问所有节点，最差情况下需要访问 N+1 个 null ，
总体复杂度为 O(2N+1)=O(N) 。
空间复杂度 O(N) ： 最差情况下，队列 queue 同时存储{N + 1}个节点（或 N+1 个 null ），使用 O(N) ；
列表 res 使用 O(N) 
```

```
反序列化
时间复杂度 O(N) ： N 为二叉树的节点数，按层构建二叉树需要遍历整个 vals ，其长度最大为 2N+1 。
空间复杂度 O(N) ： 最差情况下，队列 queue 同时存储{N + 1}个节点，因此使用 O(N) 额外空间
```

### [剑指 Offer 38. 字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)

输入一个字符串，打印出该字符串中字符的所有排列。

你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

```java
// 回溯法
class Solution {
    // 创建一个用于保存结果的数组
    List<String> res = new LinkedList<>();
    // 定义一个用于保存当前字符串排列的数组
    char[] c;
    public String[] permutation(String s) {
        // 边界处理
        if(s == null)
            return new String[0];
        // 将输入的字符串转换为对应的字符数组
        c = s.toCharArray();
        // 开始深度优先遍历，从第一位开始固定
        dfs(0);
        // 将linkedlist转化为具有同样元素的string[]
        return res.toArray(new String[res.size()]);
    }
    void dfs(int x){
        // 如果遍历到c的最后一位，说明已经到达末尾，直接将当前的字符串列表加入结果集
        if(x == c.length - 1){
            res.add(String.valueOf(c));
        }
        // 定义一个set用来存放已经固定过的字母，如果set中已经存在，那么就跳过此次循环
        HashSet<Character> set = new HashSet<>();
        // dfs(x)从第x位开始
        for(int i = x; i < c.length; i++){
            // 如果此次待交换的字母在集合中已经存在，那么就跳出此次循环
            if(set.contains(c[i])){
                continue;
            }
            // 将当前位的字符放在set中
            set.add(c[i]);
            // 交换x和x后面的每一位
            swap(x, i);
            // 开启下一层递归，即固定第x+1位
            dfs(x + 1);
            // 若该位交换完一次，则恢复交换
            swap(i, x);
        }
    }
    void swap(int a, int b){
        char tmp = c[b];
        c[b] = c[a];
        c[a] = tmp;
    }
}
```

```
时间复杂度O(N!)：N为字符串s的长度；时间复杂度和字符串排列的方案数成线性关系，方案数为N×(N−1)×(N−2)…×2×1，因此复杂度为O(N!)。
空间复杂度O(N^2)：全排列的递归深度为N，系统累计使用栈空间大小为O(N)；递归中辅助Set累计存储的字符数量最多为N+(N−1)+...+2+1=(N+1)N/2，即占用O(N^2)的额外空间。结果集是必须占用空间的，不计入额外空间。
```

### [剑指 Offer 39. 数组中出现次数超过一半的数字](https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

```java
// 哈希表统计法
class Solution {
    public int majorityElement(int[] nums) {
        // 边界判断
        if(nums == null || nums.length == 0)
            return 0;
        // 利用一个hashmap保存数据，键对应的值记录次数
        HashMap<Integer, Integer> map = new HashMap<>();
        int res = 0;
        for(int i = 0; i < nums.length; i++){
            // 如果当前数字在map中已经存在，那么对应的值加1
            if(map.containsKey(nums[i])){
                map.put(nums[i], map.get(nums[i]) + 1);
            } else{
                // 否则，将新出现的值加入map
                map.put(nums[i], 1);
            }
            // 遍历map，如果有某个键对应的值大于输入数组长度的一半，则将该键输出
            if(map.get(nums[i]) > nums.length/2)
               res = nums[i];
        }
        return res;
    }
}
```

```
时间复杂度O(N)
空间复杂度O(N)
```

```java
// 摩尔投票法
class Solution {
    public int majorityElement(int[] nums) {
        // 利用摩尔投票法来解决问题
        // 首先边界判断
        if(nums == null || nums.length == 0){
            return 0;
        }
        // 定义用于保存结果的x和统计投票数的votes
        int x = 0, votes = 0;
        // 对数组进行遍历以找出众数
        for(int num : nums){
            if(votes == 0){
                x = num;
            }
            votes += num == x ? 1 : -1;
        }
        return x;
    }
}
```

```
时间复杂度O(N)
空间复杂度O(1)
```

```
// 首先对数组进行快速排序，然后直接返回nums[nums.length()/2 + 1]即可
```

### [剑指 Offer 40. 最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)

 输入整数数组 `arr` ，找出其中最小的 `k` 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。

```java
利用数组Arrays的库函数sort排序以及copyof返回结果
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        // 边界判断
        if(k >= arr.length) return arr;
        int[] res = new int[k];
        Arrays.sort(arr);
        return Arrays.copyOf(arr, k);
    }
}
```

```java
基于快速排序，返回数组的前k小的数
设置哨兵，这是用来分割左右数组的，初始化的值为a[0]，每轮排序将比哨兵小的放左边，比哨兵大的放右边，利用递归进行排序，每轮递归都要移动哨兵，递归的终止条件是数组的元素只有一个
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        // 边界判断
        if(k >= arr.length) return arr;
        quickSort(arr, 0, arr.length - 1);
        return Arrays.copyOf(arr, k);
    }

    // 实现快排的函数
    private void quickSort(int[] arr, int l, int r){
        // 递归终止的条件是数组只有一个元素，也就是l>=r
        if(l >= r)  return;
        // 设置用于遍历数组的头尾双指针
        int i = l, j = r;
        // 遍历的终止条件是i >= j
        while(i < j){
            // 寻找右数组小于哨兵arr[l]的元素
            while(i < j && arr[j] >= arr[l]) j--;
            // 寻找左数组大于哨兵arr[l]的元素
            while(i < j && arr[i] <= arr[l]) i++;
            // 交换找到的这两个数并进行交换
            swap(arr, i, j);
        }
        // 对哨兵和左数组中最右边的元素进行交换并进行下一轮递归
        swap(arr, i, l);
        // 左数组是l~i-1，右数组是i+1~r
        quickSort(arr, l, i - 1);
        quickSort(arr, i + 1, r);
    }

    // 实现数组元素位置交换的元素
    private void swap(int[] arr, int a, int b){
        int tmp = arr[a];
        arr[a] = arr[b];
        arr[b] = tmp;
    }
}
```

```
前两种方法
时间复杂度 O(NlogN) ： 库函数、快排等排序算法的平均时间复杂度为 O(NlogN) 。
空间复杂度 O(N) ： 快速排序的递归深度最好（平均）为 O(logN) ，最差情况（即输入数组完全倒序）为 O(N)。
```

```java
// 基于快排实现，但是不要完全排序，只需要找到前k小的元素就可以
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        // 边界判断
        if(k >= arr.length) return arr;
        return quickSort(arr, k, 0, arr.length - 1); 
    }

    // 实现快排的函数，由于只需要返回前k小的数，所以只要判断哨兵是否为a[k]，如果是，则返回之前的数组就可以
    private int[] quickSort(int[] arr, int k, int l, int r){
        // 递归终止的条件是数组只有一个元素，由于不需要完全排序完，所以不要判断当前排序数组是否只有一个元素
        // 设置用于遍历数组的头尾双指针
        int i = l, j = r;
        // 遍历的终止条件是i >= j
        while(i < j){
            // 寻找右数组小于哨兵arr[l]的元素
            while(i < j && arr[j] >= arr[l]) j--;
            // 寻找左数组大于哨兵arr[l]的元素
            while(i < j && arr[i] <= arr[l]) i++;
            // 交换找到的这两个数并进行交换
            swap(arr, i, j);
        }
        // 对哨兵和左数组中最右边的元素进行交换
        swap(arr, i, l);
        // 如果当前哨兵并不是a[k]进行下一轮递归
        // 如果i > k，则需要将哨兵左移对左边数组进行递归，左数组是l~i-1
        if(i > k) return quickSort(arr, k, l, i - 1);
        // 如果i < k，则需要对哨兵右移右边数组进行递归，右数组是i+1~r
        if(i < k) return quickSort(arr, k, i + 1, r);
        return Arrays.copyOf(arr, k);
    }

    // 实现数组元素位置交换的元素
    private void swap(int[] arr, int a, int b){
        int tmp = arr[a];
        arr[a] = arr[b];
        arr[b] = tmp;
    }
}
```

```
时间复杂度 O(N) ： 其中 N 为数组元素数量；对于长度为 N 的数组执行哨兵划分操作的时间复杂度为 O(N) ；每轮哨兵划分后根据 k 和 i 的大小关系选择递归，由于 i 分布的随机性，则向下递归子数组的平均长度为N/2；因此平均情况下，哨兵划分操作一共 <2N ，即总体时间复杂度为 O(N) 。
空间复杂度O(logN):划分函数的平均递归深度为O(logN)
```

### [剑指 Offer 42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

```java
class Solution {
    public int maxSubArray(int[] nums) {
        // 使用动态规划的方法求解
        // dp[i]表示以nums[i]为结尾的所有子数组的和的最大值
        // 用nums来保存dp的结果，这样空间复杂度可以降为o(1)
        // 如果dp[i-1] < 0，则对dp[i]负贡献，dp[i] = nums[i]
        // 如果dp[i-1] > 0, 则对dp[i]正贡献，dp[i] = dp[i-1] + nums[i]
        int res = nums[0];
        // 开启遍历
        for(int i = 1; i < nums.length; i++){
            nums[i] = nums[i] + Math.max(nums[i - 1], 0);
            res = Math.max(nums[i], res);
        }
        return res;
    }
}
```

```
时间复杂度 O(N)
空间复杂度O(1)
```

