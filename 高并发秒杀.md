# 高并发秒杀

![image-20210412220151936](C:\Users\94307\OneDrive - zju.edu.cn\learnbm\JAVA\学习笔记\image-20210412220151936.png)

## 项目框架搭建

![image-20210329001800486](C:\Users\94307\OneDrive - zju.edu.cn\learnbm\JAVA\学习笔记\image-20210329001800486.png)

1.springboot quick start

https://projects.spring.io/spring-boot/
https://docs.spring.io/spring-boot/docs/1.5.8.RELEASE/reference/htmlsingle/

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>1.5.8.RELEASE</version>
</parent>
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
</dependencies>
```

3.修改pom，添加依赖

4.建立目录结构，controller，service，dao

5.创建MainApplication DemoController

```java
@SpringBootApplication
public class MainApplication {
	public static void main(String[] args) throws Exception {
       SpringApplication.run(MainApplication.class, args);
	}
}
```
6./hello/api 接口

7.创建Result

8.创建CodeMsg

9.浏览访问 http://localhost:8080/demo/hello/api

10.看文档，集成thymeleaf

```xml
<dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
```

添加配置application.properties
spring.thymeleaf.prefix=classpath:/templates/
spring.thymeleaf.suffix=.html
注意后面不能与空格 否则会找不到模板

11./hello接口  template/hello.html

```html
<!DOCTYPE HTML>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>hello</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
</head>
<body>
<p th:text="'hello:'+${name}" ></p>
</body>
</html>
```

12.集成mybatis
http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/
添加依赖：

```xml
<dependency>
	<groupId>org.mybatis.spring.boot</groupId>
	<artifactId>mybatis-spring-boot-starter</artifactId>
	<version>1.3.1</version>
</dependency>
<dependency>
	<groupId>mysql</groupId>
	<artifactId>mysql-connector-java</artifactId>
</dependency>
<dependency>
	<groupId>com.alibaba</groupId>
	<artifactId>druid</artifactId>
	<version>1.0.5</version>
</dependency>
```

添加数据源配置druid

**mybatis**

mybatis.type-aliases-package=com.imooc.miaosha.domain // 数据库扫描对象包，存放和数据库表对应的扫描对象
mybatis.mapp erLocations = classpath:com/imooc/miaosha/dao/*.xml // 把接口类和xml写在一起，比较方便
mybatis.configuration.map-underscore-to-camel-case=true // 将下划线转化为驼峰
mybatis.configuration.default-fetch-size=100
mybatis.configuration.default-statement-timeout=3000

**datasource**

-- todo，修改为自己的数据库
spring.datasource.url=jdbc:mysql://39.103.189.27/miaosha?useUnicode=true&characterEncoding=utf-8&allowMultiQueries=true&useSSL=false
spring.datasource.username=root
spring.datasource.password=12345678
spring.datasource.driver-class-name=com.mysql.jdbc.Driver

**druid**

spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
spring.datasource.filters=stat
spring.datasource.maxActive=2
spring.datasource.initialSize=1
spring.datasource.maxWait=60000
spring.datasource.minIdle=1
spring.datasource.timeBetweenEvictionRunsMillis=60000
spring.datasource.minEvictableIdleTimeMillis=300000
spring.datasource.validationQuery=select 'x'
spring.datasource.testWhileIdle=true
spring.datasource.testOnBorrow=false
spring.datasource.testOnReturn=false
spring.datasource.poolPreparedStatements=true
spring.datasource.maxOpenPreparedStatements=20

**添加config：**

```java
// 一般用来声明配置类，可以使用 @Component注解替代，不过使用@Configuration注解声明配置类更加语义化。
@Configuration
@ConfigurationProperties(prefix="spring.datasource")
public class DruidConfig {

	private String url;
	private String username;
	private String password;
	private String driverClassName;
	private String type;
	private String filters;
	private int maxActive;
	private int initialSize;
	private int minIdle;
	private long maxWait;
	private long timeBetweenEvictionRunsMillis;
	private long minEvictableIdleTimeMillis;
	private String validationQuery;
	private boolean testWhileIdle;
	private boolean testOnBorrow;
	private boolean testOnReturn;
	private boolean poolPreparedStatements;
	private int maxOpenPreparedStatements;
	
	@Bean
	public ServletRegistrationBean druidSverlet() {
		ServletRegistrationBean reg = new ServletRegistrationBean();
		reg.setServlet(new StatViewServlet());
		reg.addUrlMappings("/druid/*");
		reg.addInitParameter("loginUsername", "root");// mysql的登陆信息
		reg.addInitParameter("loginPassword", "12345678");
		reg.addInitParameter("logSlowSql", "true");
		reg.addInitParameter("slowSqlMillis", "1000");
		return reg;
	}
	
	@Bean
	public DataSource druidDataSource() {
		 	DruidDataSource datasource = new DruidDataSource();
	        datasource.setUrl(url);
	        datasource.setUsername(username);
	        datasource.setPassword(password);
	        datasource.setDriverClassName(driverClassName);
	        datasource.setInitialSize(initialSize);
	        datasource.setMinIdle(minIdle);
	        datasource.setMaxActive(maxActive);
	        datasource.setMaxWait(maxWait);
	        datasource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);
	        datasource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);
	        datasource.setValidationQuery(validationQuery);
	        datasource.setTestWhileIdle(testWhileIdle);
	        datasource.setTestOnBorrow(testOnBorrow);
	        datasource.setTestOnReturn(testOnReturn);
	        datasource.setPoolPreparedStatements(poolPreparedStatements);
	        datasource.setMaxOpenPreparedStatements(maxOpenPreparedStatements);
	        try {
	            datasource.setFilters(filters);
	        } catch (SQLException e) {
	            e.printStackTrace();
	        }
	        return datasource;
	}
}
```

添加mysql-connector、druid依赖

创建数据表User，Service、Dao、Domain
CREATE TABLE `user` (
  `id` int(11) NOT NULL,
  `name` varchar(24) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4

@Select注解

xml:
```xml
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.imooc.miaosha.dao.UserDao">
</mapper>
```

（1）getById
（2）tx @Transactional 演示

13.整合redis
（1）安装redis
下载redis安装文件 http://redis.io/ redis-4.0.2.tar.gz
wget https://download.redis.io/releases/redis-4.0.2.tar.gz
tar -zvxf redis-4.0.2.tar.gz
cd redis-4.0.2
make 
make install
src/redis-server & //启动服务器
src/redis-cli //客户端连接
util/install_server.sh 安装成系统服务
chkconfig –-list | grep redis 查看是否开机启动
(2)配置
bind 0.0.0.0 // 分布式允许多台服务器访问redis
daemonize yes // 允许后台执行
requirepass 1234567 // 设置密码
创建系统服务

添加配置 
对象序列化效率最高的是google的protobuff，输出是二进制格式，不可读
**而fastjson是可读的，效率慢一倍**
引入jedis和fastjson依赖 

```xml
<dependency>
    <groupId>redis.clients</groupId>
    <artifactId>jedis</artifactId>
</dependency>
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>fastjson</artifactId>
    <version>1.2.38</version>
</dependency>
```

添加配置：

**redis**

redis.host=10.110.3.62
redis.port=6379
redis.timeout=3
redis.password=123456
redis.poolMaxTotal=10
redis.poolMaxIdle=10
redis.poolMaxWait=3

java：
新建一个读取redis配置文件的类

```java
// springboot读取配置文件的注解prefix指定前缀
@ConfigurationProperties(prefix="redis"）
@Component
public class RedisConfig {
	private String host;
	private int port;
	private int timeout;//秒
	private String password;
	private int poolMaxTotal;
	private int poolMaxIdle;
	private int poolMaxWait;//秒
}
```

编写RedisSerive// 编写redisService提供redis服务

fastjson beantostring stringtobean

编写RedisPoolFactory

注入一个jedispool获取jedis 定义到另外一个地方RedisPoolFactory.java

> bean的定义
> springboot注入一个bean用@bean注解，再一个类中注入需要引用的类会造成循环引用

编写KeyPrefix接口 BaseKey抽象类

redis缓存加前缀防止不同的开发者写入不同的字段发生混乱
prefix + key = realkey  保证不同的类生成的key一定是不一样的，同一个模块内部通过id区分

incr decr都是原子操作，不会有中间状态

> **通用缓存key封装：**
>
> 接口<——抽象类<——实现类
>
> 接口只定义一些契约，抽象类实现一些共同的实现，实现类实现一些特殊的实现
>
> 这种设计模式叫做模板模式

## 第二章 实现登录功能

![image-20210329001852733](C:\Users\94307\OneDrive - zju.edu.cn\learnbm\JAVA\学习笔记\image-20210329001852733.png)

**第一节：**
**1.数据库设计**

```mysql
CREATE TABLE `miaosha_user` (
  `id` bigint(20) NOT NULL COMMENT '用户ID，手机号码',
  `nickname` varchar(255) NOT NULL,
  `password` varchar(32) DEFAULT NULL COMMENT 'MD5(MD5(pass明文+固定salt) + salt)',
  `salt` varchar(10) DEFAULT NULL,
  `head` varchar(128) DEFAULT NULL COMMENT '头像，云存储的ID',
  `register_date` datetime DEFAULT NULL COMMENT '注册时间',
  `last_login_date` datetime DEFAULT NULL COMMENT '上蔟登录时间',
  `login_count` int(11) DEFAULT '0' COMMENT '登录次数',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
```

密码两次MD5:

- 用户端：PASS = MD5(明文+  固定salt) ——> formpassword 

  http在网络是明文传输，md5防止恶意用户抓包 ——> dbpassword

  > md5：一种hash算法
  >
  > salt：和用户输入密码做一个拼装，可以取盐中的某些字符，加强安全性，即便加盐后的md5被拿到，也是加了盐的，而不是真正的密码

- 客户端：PASS = MD5(明文+  随机salt)

  防止数据库被盗（彩虹表反查）

**2.两次MD5：引入MD5工具类，添加MD5Util**

```xml
<dependency>
  <groupId>commons-codec</groupId>
  <artifactId>commons-codec</artifactId>
</dependency>
<dependency>
  <groupId>org.apache.commons</groupId>
  <artifactId>commons-lang3</artifactId>
  <version>3.6</version>
</dependency>
```

**1.为什么要对明文密码做两次md5然后再入库？**
 第一次md5是为了防止明文密码直接在网络上进行传输，第二次md5的目的是：假如数据库本身被泄露，那么可以增加被破解的难度，因为就算还原出来也只是一个md5以后的串，而不是用户的原始密码本身。
 **2.两次MD5就一定安全了吗？**
 不是的。如果想安全，目前通用的做法是使用https,如果想再安全一点，那就只能使用浏览器的插件比如 Activex来实现了，比如网银的那些安全控件，控件对数据做加密，因为控件本身破解的难度很高，因此相对来说是非常安全的，但是仅仅依js是无法做法数据安全的，因为**js本身都是明文**的。

**第二节：**
**3.编写login.html,引入jquery.js、bootstrap、jquery-validation、layer.js**
<!-- jquery -->

    <script type="text/javascript" th:src="@{/js/jquery.min.js}"></script>
​    <!-- bootstrap -->
​    <link rel="stylesheet" type="text/css" th:href="@{/bootstrap/css/bootstrap.min.css}" />
​    <script type="text/javascript" th:src="@{/bootstrap/js/bootstrap.min.js}"></script>
​    <!-- jquery-validator -->
​    <script type="text/javascript" th:src="@{/jquery-validation/jquery.validate.min.js}"></script>
​    <script type="text/javascript" th:src="@{/jquery-validation/localization/messages_zh.min.js}"></script>
​    <!-- layer -->
​    <script type="text/javascript" th:src="@{/layer/layer.js}"></script>
​    <!-- md5.js -->
​    <script type="text/javascript" th:src="@{/js/md5.min.js}"></script>
​    <!-- common.js -->

    <script type="text/javascript" th:src="@{/js/common.js}"></script>

<form name="loginForm" id="loginForm" method="post" >
	<h2 style="text-align:center; margin-bottom: 20px">用户登录</h2>
	<div class="form-group">
       	<div class="row">
	       	<label class="form-label col-md-4">请输入手机号码</label>
	        <div class="col-md-5">
	        	<input id="mobile" name = "mobile" class="form-control" type="text" placeholder="手机号码" required="true"  minlength="11" maxlength="11" />
	    	</div>
	    	<div class="col-md-1">
	    	</div>
    	</div>
    </div>
    <div class="form-group">
     		<div class="row">
		        <label class="form-label col-md-4">请输入密码</label>
		        <div class="col-md-5">
		        	<input id="password" name="password" class="form-control" type="password"  placeholder="密码" required="true" minlength="6" maxlength="16" />
	       		</div>
      		</div>
	</div>
	<div class="row">
		     	<div class="col-md-5">
	       	 		<button class="btn btn-primary btn-block" type="reset" onclick="reset()">重置</button>
	       	 	</div>
	       	 	<div class="col-md-5">
	       	 		<button class="btn btn-primary btn-block" type="submit" onclick="login()">登录</button>
	       	 	</div>
	 </div>
</form>
function login(){
$('#loginForm').validate({
        submitHandler:function(form){
            doLogin();
        }    
    });
}
function doLogin(){
	g_showLoading();
	var pass = md5(g_passsword_salt.charAt(0)+g_passsword_salt.charAt(7)+$("#password").val()+g_passsword_salt.charAt(4)+g_passsword_salt.charAt(3))
	console.log(pass)
	$.ajax({  
        type : "POST",  
        url :  "/login/do_login",  
        data : {
        	"mobile":$("#mobile").val(),
        	"password":pass
        },
        success : function(data){  
        	layer.closeAll();
        	if(data.code == 0){
        		layer.msg("登录成功",{time: 1000},function(){
        			window.location.href="/goods/to_list";
        		});
        	}else{
        		alert(data.msg);
        	}
        },
        error: function(XMLHttpRequest, textStatus, errorThrown) {
        	layer.closeAll();
        	alert("异常");
        }
	}); 
}

LoginController的编写，这个用来校验输入的手机号和密码是否满足要求，并且完成相应的登录操作

注入service

public class MiaoshaUser {
	private Long id;
	private String nickname;
	private String password;
	private String salt;
	private String head;
	private Date registerDate;
	private Date lastLoginDate;
	private Integer loginCount;
}

MiaoshaUserDao的编写：采用注解的方式@Mapper @select，用来编写sql语句，完成用户密码的设置和查询

MiaoshaUserService的编写：注入dao

**第三节：**
**4.引入spring-boot-starter-validation**
自定义参数校验器+全局异常处理器 

**引入JSR303参数校验的依赖**

可以用来校验参数是否满足格式要求

```xml
<dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>
```

定义一个注解用来调用校验器

```java
@Target({ElementType.ANNOTATION_TYPE, ElementType.METHOD, ElementType.FIELD})  
@Retention(RetentionPolicy.RUNTIME)  
@Documented  
@Constraint(validatedBy = IsMobileValidator.class)// 系统看到此注解会调用校验器进行校验
public @interface  IsMobile {// 定义一个注解
	
	boolean required() default true;// 允许不传此参数
	
	String message() default "手机号码格式错误";// 如果校验不通过提示的信息

	Class<?>[] groups() default { };

	Class<? extends Payload>[] payload() default { };
}
```

定义一个校验器

```java
public class IsMobileValidator implements ConstraintValidator<IsMobile, String> {

	private boolean required = false;
	
	@Override// 初始化拿到注解
	public void initialize(IsMobile constraintAnnotation) {
		required = constraintAnnotation.required();
	}

	@Override// 判断是否合法
	public boolean isValid(String value, ConstraintValidatorContext context) {
		if(required) {// 如果需要则需要判断是否合法
			return ValidatorUtil.isMobile(value);
		}else {// 如果不需要又为空
			if(StringUtils.isEmpty(value)) {
				return true;
			}else {// 如果不为空就返回值
				return ValidatorUtil.isMobile(value);
			}
		}
	}
}
```

拦截异常，使得异常显示更为友好，输出一个用户信息即可

GlobalExceptionHandler和controller很相似

@ExceptionHandler(value=Exception.class)表示想拦截的是哪些class

```java
@ControllerAdvice
@ResponseBody
public class GlobalExceptionHandler {
    @ExceptionHandler(value=Exception.class)  
    public Result<String> allExceptionHandler(HttpServletRequest request, Exception exception) throws Exception{  
    }
}
```

所有的方法再改造之后在开头不需要做参数校验

定义一个全局异常，一旦业务代码也就是service出现异常，直接抛出异常

当logincontroller调用service做登陆时发生异常直接往外抛即可，抛出异常后，全局异常处理器会拦截异常，将异常拦截后输出

**第四节：**
**6.分布式Session**（将token存放到cookie，将用户信息放到缓存，根据token取redis中取用户信息）

秒杀实际中一定不可能只有一台服务器，肯定是有多台服务器

如果用户的第一个请求落到了第一个服务器，而第二个请求落到了第二个服务器上，那么session信息就全部丢失了

> 容器可以提供原生的session同步，一台服务器的session同步到另一台服务器上，集群中无论哪一台服务器都会保存有用户的session，这种方式实际中应用的比较少，首先是性能问题，其次是实现起来比较复杂
>
> 比如有十台服务器，所有的session都要同步，需要消耗许多资源

服务端在用户登录成功给用户返回一个token(代表)相当于sessionid(ssid)来表示用户，写入到cookie当中，cookie写入到response中，同时第一次登陆时用户信息也会存放到redis缓存中，传递给客户端，客户端在随后的访问中都在cookie中上传这个token，然后服务端拿到token之后就据此到redis中取到用户对应的session信息。

cookie的过期时间和token一样，有效期是最后依次登录时间加上过期时间

首先生成一个uuid的帮助类

```java
public class UUIDUtil {
	public static String uuid() {
		return UUID.randomUUID().toString().replace("-", "");
	}
}
```

需要知道token：uuid对应的哪一个用户，需要把用户信息写到redis当中

核心就是把私人信息存放到一个第三方的缓存当中，十分高效

MiaoShaUserKey.java定义了秒杀userkey的前缀，根据token就可以知道用户信息了 token即是key，用户信息即是value

登录成功即跳转到商品列表页good_list，新建一个goodController跳转到此页面

测试要点：用户信息能否写到redis当中，cookie能否写到response当中



实现有效期延长，即最终的有效期是用户最后登录时间+过期时间

注入user的方法：新建一个webconfig 使用springMVC框架

框架回调addArgumentResolvers方法往controller里的方法赋值

编写UserArgumentResolver解析user对象，这样子即使以后获取session的方式改变了，只需要在此调整即可，不用在业务中调整，里面实现了和客户端兼容，不想从cookie传参，想从参数传参，不需要修改后端代码

**分布式session的一些优化——双token刷新机制**

不需要每次访问都去刷新token课程中在每次调用 getby Token（）去获取用户信息的时候，都去做了一件事：那就是去延长当前 token的有效期

![image-20210404174306704](C:\Users\94307\OneDrive - zju.edu.cn\learnbm\JAVA\学习笔记\image-20210404174306704.png)

这样在访问频繁的系统中对 redis的压力太大了，更常用的一种做法是：登录成功以后返回两个 token:一个是 accesstoken,另一个是 refreshtoken 其中， accessToken就是课程中所讲的那个 token,但是当用户带着 accessToken来访问的时候，并不去刷新 accessToken, 而是**提供一个 refreshTokenl的方法，让客户端定时来调用**，调用的时侯需要传递refreshToken。这样，就可以最大限度的減少 accessToken的刷新。

**todo双token刷新机制**

 token过期了**活跃**用户需要在登录页面重新登录 问题，我们需要**token刷新**

第一次用账号密码登录服务器会返回两个 token : access_token 和 refresh_token，时效长短不一样。短的access_token 时效过了之后，发送时效长的 refresh_token 重新获取一个短时效token，如果都过期，就需要重新登录了。

refresh_token 就是用来刷新access_token 。活跃用户的 access_token 过期了，用refresh_token 获取 新的access_token 。

## 第三章 实现秒杀功能



![image-20210329001911363](C:\Users\94307\OneDrive - zju.edu.cn\learnbm\JAVA\学习笔记\image-20210329001911363.png)

**1.秒杀数据库设计**

数据库：商品表——订单表——秒杀商品表——秒杀订单表

秒杀商品表创建的目的：如果每一次活动如秒杀大促包邮都在商品表中添加秒杀的字段，那么商品表将变得越来越臃肿，难以维护

**商品表**

```mysql
CREATE TABLE `goods` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '商品ID',
  `goods_name` varchar(16) DEFAULT NULL COMMENT '商品名称',
  `goods_title` varchar(64) DEFAULT NULL COMMENT '商品标题',
  `goods_img` varchar(64) DEFAULT NULL COMMENT '商品的图片',
  `goods_detail` longtext COMMENT '商品的详情介绍',
  `goods_price` decimal(10,2) DEFAULT '0.00' COMMENT '商品单价',
  `goods_stock` int(11) DEFAULT '0' COMMENT '商品库存，-1表示没有限制',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4;

INSERT INTO `goods` VALUES (1,'iphoneX','Apple iPhone X (A1865) 64GB 银色 移动联通电信4G手机','/img/iphonex.png','Apple iPhone X (A1865) 64GB 银色 移动联通电信4G手机',8765.00,10000),(2,'华为Meta9','华为 Mate 9 4GB+32GB版 月光银 移动联通电信4G手机 双卡双待','/img/meta10.png','华为 Mate 9 4GB+32GB版 月光银 移动联通电信4G手机 双卡双待',3212.00,-1);
```

**秒杀商品表**

```mysql
CREATE TABLE `miaosha_goods` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '秒杀的商品表',
  `goods_id` bigint(20) DEFAULT NULL COMMENT '商品Id',
  `miaosha_price` decimal(10,2) DEFAULT '0.00' COMMENT '秒杀价',
  `stock_count` int(11) DEFAULT NULL COMMENT '库存数量',
  `start_date` datetime DEFAULT NULL COMMENT '秒杀开始时间',
  `end_date` datetime DEFAULT NULL COMMENT '秒杀结束时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4;

INSERT INTO `miaosha_goods` VALUES (1,1,0.01,4,'2017-11-05 15:18:00','2017-11-13 14:00:18'),(2,2,0.01,9,'2017-11-12 14:00:14','2017-11-13 14:00:24');
```

**订单表**

```mysql
CREATE TABLE `order_info` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) DEFAULT NULL COMMENT '用户ID',
  `goods_id` bigint(20) DEFAULT NULL COMMENT '商品ID',
  `delivery_addr_id` bigint(20) DEFAULT NULL COMMENT '收获地址ID',
  `goods_name` varchar(16) DEFAULT NULL COMMENT '冗余过来的商品名称',
  `goods_count` int(11) DEFAULT '0' COMMENT '商品数量',
  `goods_price` decimal(10,2) DEFAULT '0.00' COMMENT '商品单价',
    -- 订单的渠道
  `order_channel` tinyint(4) DEFAULT '0' COMMENT '1pc，2android，3ios',
  `status` tinyint(4) DEFAULT '0' COMMENT '订单状态，0新建未支付，1已支付，2已发货，3已收货，4已退款，5已完成',
  `create_date` datetime DEFAULT NULL COMMENT '订单的创建时间',
  `pay_date` datetime DEFAULT NULL COMMENT '支付时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8mb4;
```

**秒杀订单表**

```mysql
CREATE TABLE `miaosha_order` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) DEFAULT NULL COMMENT '用户ID',
  `order_id` bigint(20) DEFAULT NULL COMMENT '订单ID',
  `goods_id` bigint(20) DEFAULT NULL COMMENT '商品ID',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4;
```

**创建对应的domain方法**

```java
public class Goods {
	private Long id;
	private String goodsName;
	private String goodsTitle;
	private String goodsImg;
	private String goodsDetail;
	private Double goodsPrice;
	private Integer goodsStock;
}
```

```java
public class MiaoshaGoods {
	private Long id;
	private Long goodsId;
	private Integer stockCount;
	private Date startDate;
	private Date endDate;
}
```

```java
public class OrderInfo {
	private Long id;
	private Long userId;
	private Long goodsId;
	private Long  deliveryAddrId;
	private String goodsName;
	private Integer goodsCount;
	private Double goodsPrice;
	private Integer orderChannel;
	private Integer status;
	private Date createDate;
	private Date payDate;
}
```

```java
public class MiaoshaOrder {
	private Long id;
	private Long userId;
	private Long  orderId;
	private Long goodsId;
}
```

```java
public class GoodsVo extends Goods{
	private Double miaoshaPrice;
	private Integer stockCount;
	private Date startDate;
	private Date endDate;
}
```

**创建对应的GoodsService类**

在service中注入goodsdao

**创建GoodsDao类**

**创建GoodsVo类**，继承了商品类同时还有秒杀商品的一些属性

> vo value object表现层对象

**修改GoodsController**

加入GoodsService并且完成注入

**2.商品列表**

good_list.html编写，thymeleaaf提供，可以查询文档

点击详情可以跳转到商品的详情页

<div class="panel panel-default">
  <div class="panel-heading">秒杀商品列表</div>
  <table class="table" id="goodslist">
  	<tr><td>商品名称</td><td>商品图片</td><td>商品原价</td><td>秒杀价</td><td>库存数量</td><td>详情</td></tr>
  	<tr  th:each="goods,goodsStat : ${goodsList}">  
                <td th:text="${goods.goodsName}"></td>  
                <td ><img th:src="@{${goods.goodsImg}}" width="100" height="100" /></td>  
                <td th:text="${goods.goodsPrice}"></td>  
                <td th:text="${goods.miaoshaPrice}"></td>  
                <td th:text="${goods.stockCount}"></td>
                <td><a th:href="'/goods/to_detail/'+${goods.id}">详情</a></td>  
     </tr>  
  </table>
</div>
**3.商品详情**

**修改GoodsController**

在其中添加跳转的方法，to_detail方法

> 在数据库设计中，很少设置主键id自增长，也不会设置uuid，应为是32为16进制数，太长了，放在索引中很冗长，造成主键索引频繁分裂，减缓搜索速度。有一种解决方案是使用**snowflake算法**，twitter设计的

**在GoodsService中添加getGoodsVoByGoodsId**

**在GoodsDao中创建getGoodsVoByGoodsId以及sql查询语句**

**商品详情页的编写**

判断用户信息是否完整

**秒杀倒计时**

秒杀是否开始，实现一个倒计时的功能

未开始0、开始1、结束2

**只有在秒杀开始的时候秒杀按钮才能够点，否则需要将秒杀按钮置灰，这是前端的任务**

倒计时是在客户端完成的，要是都请求服务端的话量非常大，没法和服务端的时间保持一致，偶尔不精确，可以想办法保持同步

页面从接收到服务器响应的时间戳开始计时，计时的时长应减掉AJAX从发送到接收整个过程的耗时，计时过程则使用本地时间来实现（本地时间+时间偏差）。

**实现秒杀功能**

总共有四步，首先判断库存，然后判断是否重复秒杀，然后减库存，下订单(订单表，秒杀订单表)

就是做了一个表单的提交，提交了商品id，用**MiaoController类**实现秒杀功能

do_miaosha

**首先判断用户是否登录**，如果没有登录首先登录

**判断库存是否为空**，如果库存为空，直接返回秒杀失败，**秒杀失败的页面**

**判断是否秒杀到了**，防止一个人秒杀了多次商品，返回重复秒杀

这是在orderservice中完成查询的，

创建**OrderService**，注入OrderDao

OrderService中下单操作也需要放在一个事务中进行

创建**OrderDao**

**减库存，下订单，写入秒杀订单**（原子操作），**订单详情页**

只有减库存成功才会生成订单

某个用户秒杀了某个商品，返回生成的订单，秒杀成功之后直接进入订单详情页有订单信息orderInfo，商品信息goods

这几步需要放在一个事务中进行，一步成功，其他两步必须要成功，一步失败，其他两步都不许失败

**创建MiaoshaService**

同一个service尽量值注入自己的dao，如果要注入其它的dao则要注其他的service

<div class="panel panel-default">
  <div class="panel-heading">秒杀商品详情</div>
  <div class="panel-body">
  	<span> 您还没有登录，请登陆后再操作<br/></span>
  	<span>没有收货地址的提示。。。</span>
  </div>
  <table class="table" id="goodslist">
  	<tr>  
        <td>商品名称</td>  
        <td colspan="3"></td> 
     </tr>  
     <tr>  
        <td>商品图片</td>  
        <td colspan="3"><img th:src="" width="200" height="200" /></td>  
     </tr>
     <tr>  
        <td>秒杀开始时间</td>  
        <td ></td>
        <td id="miaoshaTip">	
        	<span>秒杀已经结束</span>
        </td>
        <td>
        	<form id="miaoshaForm" method="post" action="/miaosha/do_miaosha">
        		<button class="btn btn-primary btn-block" type="submit" id="buyButton">立即秒杀</button>
        		<input type="hidden" name="goodsId" th:value="${goods.id}" />
        	</form>
        </td>
     </tr>
     <tr>  
        <td>商品原价</td>  
        <td colspan="3"></td>  
     </tr>
      <tr>  
        <td>秒杀价</td>  
        <td colspan="3"></td>  
     </tr>
     <tr>  
        <td>库存数量</td>  
        <td colspan="3"></td>  
     </tr>
  </table>
</div>
<td th:text="${#dates.format(goods.startDate, ''yyyy-MM-dd HH:mm:ss)}"></td>

**4.订单详情**

显示订单详情

商品名称+商品图片+订单价格+下单时间+订单状态+收货人+收获地址

订单状态0新建未支付，1已支付，2已发货，3已收货，4已退款，5已完成

> 如果是一些其他的例如手机充值，状态需要跟着改

<div class="panel panel-default">
  <div class="panel-heading">秒杀订单详情</div>
  <table class="table" id="goodslist">
        <tr>  
        <td>商品名称</td>  
        <td th:text="" colspan="3"></td> 
     </tr>  
     <tr>  
        <td>商品图片</td>  
        <td colspan="2"><img th:src="@{}" width="200" height="200" /></td>  
     </tr>
      <tr>  
        <td>订单价格</td>  
        <td colspan="2"></td>  
     </tr>
     <tr>
     	<td>下单时间</td>  
        	<td th:text="" colspan="2"></td>  
     </tr>
     <tr>
     	<td>订单状态</td>  
        <td>
        </td>  
        <td>
        	<button class="btn btn-primary btn-block" type="submit" id="payButton">立即支付</button>
        </td>
     </tr>
      <tr>
     	<td>收货人</td>  
        	<td colspan="2">XXX  18812341234</td>  
     </tr>
     <tr>
     	<td>收货地址</td>  
        	<td colspan="2">北京市昌平区回龙观龙博一区</td>  
     </tr>
  </table>
</div>
<td th:text="${#dates.format(orderInfo.createDate, 'yyyy-MM-dd HH:mm:ss')}" colspan="2"></td>  

## 第四章 JMeter压测



![image-20210329001944834](C:\Users\94307\OneDrive - zju.edu.cn\learnbm\JAVA\学习笔记\image-20210329001944834.png)

在本机的虚拟机中跑

**JMeter入门**

准确的说法：并发在多少的时候，网站的qps是多少

> TPS (transaction per second)代表每秒执行的事务数量
>
> QPS（Queries-per-second） 每秒查询率
>
> 事务：客户端发起请求到收到服务端最终响应的整个过程，这是一个TPS
>
> 而在这个TPS中，为了处理第一次请求可能会引发后续多次对服务端的访问才能完成这次工作，每次访问都算一个QPS。
>
> 所以，一个TPS可能包含多个QPS

聚合报告，并发在1000的时候，qps只有84，瓶颈在数据库

并发在10000时，qbs192.6，服务器负载超过3，已经有很多进程在等待了

**自定义变量模拟多用户**

编写usercontroller获取用户的个人信息

1000个请求，qps差不多431，getByToken，由于读的是缓存

配置元件csv data set config，导入文件，变量的名字，定义了几个就写几个，分隔符等等

userid1.usertoken1

userid2.usertoken2

userid3.usertoken3

可以设置recycle，然后再httprequest中写入${userToken}，也就是配置文件的变量

这一次1000个请求，qps差不多686.9，由于之前有热身，redis中已经有缓存了

**redis压测工具redis-benchmark**

**1.redis-benchmark**

redis-benchmark -h 127.0.0.1 -p 6379 -c 100 -n 100000 
100个并发连接，100000个请求，get请求一秒可以完成10w，以3bytes进行测试

<img src="C:\Users\94307\OneDrive - zju.edu.cn\learnbm\JAVA\学习笔记\image-20210405140722943.png" alt="image-20210405140722943" style="zoom:80%;" />



redis-benchmark -h 127.0.0.1 -p 6379 -q -d 100 
存取大小为100字节的数据包，10w qps

<img src="C:\Users\94307\OneDrive - zju.edu.cn\learnbm\JAVA\学习笔记\image-20210405141450617.png" alt="image-20210405141450617" style="zoom:80%;" />

redis-benchmark -t set,lpush -n 100000 -q
只测试某些操作的性能set，lpush 11wqps

<img src="C:\Users\94307\OneDrive - zju.edu.cn\learnbm\JAVA\学习笔记\image-20210405141534962.png" alt="image-20210405141534962" style="zoom:80%;" />

redis-benchmark -n 100000 -q script load "redis.call(‘set’,‘foo’,‘bar’)"
只测试某些数值存取的性能 12w qps

<img src="C:\Users\94307\OneDrive - zju.edu.cn\learnbm\JAVA\学习笔记\image-20210405141822071.png" alt="image-20210405141822071" style="zoom:80%;" />

**2.打war包**
（1）修改pom

```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-tomcat</artifactId>
	<scope>provided</scope>
</dependency>
```

  编译时通过就可以了，运行时不需要，运行时是由tomcat的

maven-war-plugin放在一个build中，修改artifactid打出来是一个war包

```xml
<finalName>${project.artifactId}</finalName>    
<plugin>
	<groupId>org.apache.maven.plugins</groupId>
	<artifactId>maven-war-plugin</artifactId>
	<configuration>
		<failOnMissingWebXml>false</failOnMissingWebXml>
	</configuration>
</plugin>
```

（2）修改启动类

```java
public class MainApplication extends SpringBootServletInitializer{
	    @Override
	    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
	        return builder.sources(MainApplication.class);
	    }
}
```

这样即可以以jar包形式跑又可以以war包形式跑

**3.JMeter命令行压测**

在windows上录好jmx

命令行：sh jmeter.sh -n -t XXX.jmx -l result.jtl 

-n不使用图形界面 -t使用脚本 -l保存输出结果到result.jtl 

把result.jtl导入到jmeter

这是打jar包的插件

```xml
<plugin>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-maven-plugin</artifactId>
</plugin>
```

nohup java -jar -server -Xmx2048m -Xms2048m  miaosha.jar &

nohup: 忽视输出并且把输出追加到”nohup.jar“

录制goods_list.jmx脚本，上传到服务器，5000 0 10 并发数 延迟时间 循环次数

jmeter安装到linux服务器

jmeter.sh -n -t goods_list.jmx -l result.jtl执行脚本进行压测，4核的服务器负载有13，说明进程发生严重阻塞，java，jmeter（java写的），mysql几个进程

下载result.jtl结果文件 sz.result.jtl，用window的jmeter客户端加载文件，查看聚合报告，发现qps大概有600，这是一次热身

删除刚才的结果文件rm -rf result.jtl

再次执行nohup java -jar -server -Xmx2048m -Xms2048m  miaosha.jar &

系统负载到9

下载result.jtl结果文件 sz.result.jtl，用window的jmeter客户端加载文件，查看聚合报告，发现qps大概有1267，将这个作为基准，后续对其进行优化

后面在对秒杀进行压测，需要更改一下

（1）列表页压测-记录QPS 

```
QPS:1267 load:15 mysql -- 第二次
5000 * 10
```

（2）秒杀压测，记录QPS，模拟多用户卖超，改sql，同一个用户卖超加主键

-- 业务有判断库存，是否重复秒杀，如果不是那么才减库存，下订单，写入秒杀订单，比较复杂

生成多用户然后导入csv data set config，在http请求中添加两个参数

一个是商品id value；另外一个是token，value是${token}

生成miaosha.jmx上传到服务器 5000 0 10 并发数 延迟时间 循环次数，需要把jmx中的存放用户信息的路径改为服务器的路径/tmp

```
QPS:1306 load:15 mysql
5000 * 10
```

**发现商品超卖了，超卖原因：**商品有1个库存，两个线程过来发现都有库存，就都去执行秒杀，恰巧之前又都没有秒杀到，所以都执行减库存，下订单的操作，导致都减1，商品超卖

## 第五章 页面优化技术

![image-20210329002215405](C:\Users\94307\OneDrive - zju.edu.cn\learnbm\JAVA\学习笔记\image-20210329002215405.png)

jsp+thymeleaf都是动态页面，让所有的页面都是静态的html，通过js和ajax请求服务端，拿到数据渲染页面，浏览器把html缓存到客户端，只需要缓存动态数据，实现前后端分离

**1.redis缓存详情页**
第一节

页面缓存+url缓存+对象缓存

（1）页面缓存：有效期一般比较短，这里设了60s，缓存的目的是为了减少服务器的压力，而如果缓存的时间太长的话，那么页面缓存的及时性就不是很好。需要对及时性和缓存的有效期做一个折中

1 取缓存

2 手动渲染模板

3 结果输出

商品列表

```java
String html = redisService.get(GoodsKey.getGoodsList, "", String.class);
if(html == null || html.length() <= 0) {
	List<GoodsVo> goodsList = goodsService.listGoodsVo();
	model.addAttribute("goodsList", goodsList);
	//手动渲染模板
	html = renderTemplate("goods_list", model, thymeleafViewResolver,request,response,applicationContext);
	if(html!=null && html.length() > 0) {
		redisService.set(GoodsKey.getGoodsList, "", html);
	}
}
```

（2）url缓存：商品详情，缓存时间比较短，一般也就60s

不同的商品有不同的缓存，取缓存-手动渲染模板-结果输出

页面缓存和url缓存不是每个都需要缓存，一般知识缓存前1，2页



第二节
（3）热点数据对象缓存：用户token，getById改造

对象设置为永不过期，只要对象没有发生变化，那么就一直可用

getById流程：**取缓存**，如果缓存没有，那么就从数据库找，查找完将对象加载进内存

更新密码模块，如果getbyid获取不到，那么就输出用户不存在，否则就要取**更新数据库的数据**，然后**再更新缓存中的数据**

更新完数据库后需要更新缓存，否则会出现缓存数据不一致

**这个顺序不可以反过来，旁路缓存更新模式**，加入更新数据前，先把缓存的东西删掉了，这时过来一个读操作，那么没读到，取读数据库的内容，加载到缓存中的(就内容)，然后又做了更新，数据库的内容是新的，数据不一致。

更新数据库密码需要提供数据库密码修改语句update password

**（4）压测商品列表，对比QPS**，进行页面缓存和对象缓存后的压测

```
QPS:2200, load:5 -- 加了页面缓存之后，第一次热身
QPS:2884, load:5 -- 第二次压测
```



**2.页面静态化，把页面缓存到客户端**

不需要将页面缓存到redis中，只需要将动态数据通过接口传递给客户端

常用技术Angular.js、Vue.js

可以实现前后端分离，利用浏览器的缓存

**使用html+ajax实现页面静态化**

第一节：
**（1）详情页静态化改造**

新建一个detail把原来的取缓存等操作去掉，只保留一些静态操作html，动态数据通过接口和ajax从服务端获取

定义GoodDetailVo，商品，秒杀状态，剩余时间

static/goods_detail.htm——>后缀名改为htm，否则还是会找html
直接在客户端实现goods_list.html的跳转换成'/goods_detail.htm?goodsId='+${goods.id}
修改goods_detail.htm里面的js：
第二节：

**优化秒杀接口，前后端分离**

**（2）改造秒杀接口，演示浏览器缓存，动态数据调服务端接口**

打开浏览器，请求url页面，打开开发者工具，发现状态码返回的是一个304，表示页面没有发生变化，可以直接使用本地的数据，但是这样还是会和服务端去进行比对

> 浏览器缓存
>
> Pragma：http1.0
>
> Expire：http1.1 格林尼治 时序性质的
>
> Cache-control：http1.1 单位是秒 300s

修改配置：这样只有动态数据需要去和服务端进行交互，其余的静态数据全部是使用本地的缓存
spring.resources.add-mappings=true
spring.resources.cache-period= 3600 缓存时间
spring.resources.chain.cache=true 
spring.resources.chain.enabled=true
spring.resources.chain.gzipped=true
spring.resources.chain.html-application-cache=true
spring.resources.static-locations=classpath:/static/
第三节：
**（3）订单详情静态化，解决超卖问题**（sql判断库存是否大于0，给秒杀订单秒添加唯一索引gid，uid）

根据参数获取服务端数据，然后将页面渲染出来

ordervo一般是用于显示的类

修改减少库存的SQL，要判断库存是大于0才能减，数据库会对这条记录加一个行锁，不会出现两个数据更新同一条数据的情况，通过数据库保证不会超卖，但是不够

例如库存有10，但某一个用户抓取接口，同时发出了两个请求req1，req2，首先判断库存是否大于0，由于这两个请求之前都没有秒杀过，所以会进行减库存，下订单，写入秒杀订单的操作，**导致一个用户重复秒杀**，在秒杀订单表加一个**唯一索引**，商品id+用户id，秒杀订单表一个用户只能写入一条记录，如果重复秒杀，会报错，事务会回滚，同时在实际情况中，用户在提交订单前会进行验证，也保证了不会重复秒杀

判断是否已经秒杀的时候，不查数据库，去查缓存，这是一点小优化

**压测秒杀接口**， **同一个token  同一个goodsId,20个并发 演示卖超**

nohup java -jar miaosha.jar执行秒杀

jmeter.sh -n -t miaosha.jmx -l result.jtl

top看服务器负载

```
第一次qps900多，load 11左右，发现不会买超
```


synchronized()? redis分布式锁？

下一章对接口进行优化！

**3.静态资源优化**
（1）**js/css压缩**，min压缩版的js
（2）**多个js/css合并**，减少连接数，三次握手，首次连接，加载比较慢

淘宝自己做了一个tengine，可以组合多个js/css

webpack专门打包前端资源

（3）**CDN（内容分发网络）就近访问**，用户总是访问离自己最近，负载小，流量小的网络节点，解决网络拥堵

## 第六章 接口优化

![image-20210329002239196](C:\Users\94307\OneDrive - zju.edu.cn\learnbm\JAVA\学习笔记\image-20210329002239196.png)

![image-20210329002304433](C:\Users\94307\OneDrive - zju.edu.cn\learnbm\JAVA\学习笔记\image-20210329002304433.png)

秒杀的并发很大，仅仅依靠缓存没有用，需要优化接口，分库分表（mycat阿里巴巴开发，暂且不完成）

**1.优化秒杀接口，目标：2000并发 QPS 4000**

**思路：要减少数据库的访问，没必要每次都查询数据库**

**redis预减库存减少数据库访问，内存标记减少redis访问**
(1)系统初始化，把商品库存数量加载到redis

(2)收到请求，redis预减缓存，库存不足则返回(首先看redis的标志，如果已经结束，直接返回)，否则进入（3）

(3)请求先入队缓冲，异步下单，增强用户体验，直接返回，并不是返回成功，而是**返回排队中**，客户端不能直接提示秒杀成功，而是启动定时器，过一段时间再去查是否成功

(4)请求出队，生成订单，修改库存，修改结束标志

(5)客户端轮询，是否秒杀成功

2.安装RabbitMQ
(1)安装erlang rabbitMQ依赖这个 语言

http://www.erlang.org/downloads OTP 20.1 Source File 

yum install  ncurses-devel
tar xf otp_src_20.1.tar.gz
cd otp_src_20.1
./configure --prefix=/usr/local/erlang20 --without-javac --with-ssl
 make
 make install
 erl验证

(2)安装RabbitMQ
安装python
yum install python -y
安装simplejson
yum install xmlto -y
yum install python-simplejson -y

下载源码：http://www.rabbitmq.com/download.html
Generic Unix -> rabbitmq-server-generic-unix-3.6.14.tar.xz

xz -d rabbitmq-server-generic-unix-3.6.14.tar.xz
tar xf rabbitmq-server-generic-unix-3.6.14.tar
mv rabbitmq_server-3.6.14 /usr/local/rabbitmq

修改环境变量：/etc/profile:
export PATH=$PATH:/usr/local/ruby/bin:/usr/local/erlang20/bin:/usr/local/rabbitmq/sbin
source /etc/profile
./rabbitmq-server启动rabbitMQ server 5672端口监听
rabbitmqctl stop 停止

第二节：
1.SpringBoot集成RabbitMQ
（1）添加依赖

amqp是消息队列的标准协议

```xml
<dependency>  
<groupId>org.springframework.boot</groupId>  
<artifactId>spring-boot-starter-amqp</artifactId>  
</dependency>  
```

（2）添加配置：

```properties
spring.rabbitmq.host=10.110.3.62
spring.rabbitmq.port=5672
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest
spring.rabbitmq.virtual-host=/
```

消费者数量

```properties
spring.rabbitmq.listener.simple.concurrency= 10
spring.rabbitmq.listener.simple.max-concurrency= 10
```

消费者每次从队列获取的消息数量

```properties
spring.rabbitmq.listener.simple.prefetch= 1
```

消费者自动启动

```properties
spring.rabbitmq.listener.simple.auto-startup=true
```

消费失败，自动重新入队

```properties
spring.rabbitmq.listener.simple.default-requeue-rejected= true
```

启用发送重试

```properties
spring.rabbitmq.template.retry.enabled=true 
spring.rabbitmq.template.retry.initial-interval=1000 
spring.rabbitmq.template.retry.max-attempts=3
spring.rabbitmq.template.retry.max-interval=10000
spring.rabbitmq.template.retry.multiplier=1.0
```

(3)MQSender：创建发送者

(4)MQReceiver：创建消费者

2.为了让guest用户能远程连接，修改rabbitmq的配置/usr/local/rabbitmq/etc/rabbitmq/rabbitmq.config
添加：[{rabbit, [{loopback_users, []}]}].
重新启动
http://www.rabbitmq.com/access-control.html

启用管理控制台
./sbin/rabbitmq-plugins enable rabbitmq_management
重启rabbitmq。

3.添加demo测试

4.admin
rabbitmq-plugins enable rabbitmq_management 

5.4种exchange交换机
FanoutExchange: 将消息分发到所有的绑定队列，无routingkey的概念  
HeadersExchange ：通过添加属性key-value匹配  
**DirectExchange:  按照routingkey分发到指定队列**  
TopicExchange:  多关键字匹配  

消息队列的作用

1. **通过异步处理提高系统性能（减少响应所需时间）。**
2. **削峰/限流**
3. **降低系统耦合性。**

第三节：
**1.修改秒杀接口**
(1)系统初始化，把商品库存加载到redis，是否结束的标记放内存
MiaoshaService implements InitializingBean
(2)收到请求，首先查看内存标记（商品是否卖完，是一个map，通过商品id查询）如果已经结束，直接返回，后续的操作不用了，否则然后减少redis的库存（预减库存），如果已经结束，返回秒杀失败，设置标记，直接返回，否则判断是否重复秒杀，如果是就返回重复秒杀，否则进入(3)
(3)入队sender缓冲（用户信息和商品信息，miaoshamessage），直接返回，并不是返回成功，而是**返回排队中**，客户端不能直接提示秒杀成功，而是启动定时器，过一段时间再去查是否成功
(4)请求出队receiver（string类型的消息还原成bean对象miaoshamessage），查询库存，判断是否重复生成订单（这里是查询redis不是很耗性能，也可以选择不检查，因为数据库有唯一索引），修改实际库存（减库存失败了就不用生成订单了），生成秒杀订单，插入订单，插入秒杀订单，插入redis中。
(5)添加查询接口，客户端轮询，是否秒杀成功

这里需要添加查询接口，查询是否生成订单，如果生成订单成功，应该返回的是订单id，如果库存不足，返回秒杀失败，如果还是在排队（判断是不是因为商品卖完了，在redis设置一个结束标记），继续去轮询（设置每50ms轮询一次）。

整个过程没有阻塞 

```js
// 这里是秒杀成功的js代码
layer.confirm('恭喜你，秒杀成功！查看订单?', 
	{btn: ['否','是'] }, 
	function(){
		layer.closeAll();
	}, 
	function(){
		layer.closeAll();
		window.location.href="/order/detail/"+status;
	}
);
```

在miaoshacontroller中建立一个localovermap，存放商品id和是否结束的标记

![image-20210406101543451](C:\Users\94307\OneDrive - zju.edu.cn\learnbm\JAVA\学习笔记\image-20210406101543451.png)

判断内存标记是否为true，如果为true那么就秒杀结束，直接返回一个error

而在预减库存之后，判断库存是否小于0，如果小于0，那么就设置秒杀结束标记，同时此人秒杀失败；不能在等于0的时候设置秒杀结束标记，倘若一个人秒杀了最后一个商品，此时预减库存之后，库存为0，这时候，由于设置秒杀标记和返回失败在一起，所以最后一个秒杀失败。也就是说，只有预减完库存小于0，即执行秒杀前库存为0，秒杀失败，设置秒杀标志。

在之后的请求过来，首先查询内存标记，如果标记为true直接返回秒杀失败，不会访问redis，也不会发给数据库

**2.再压测**（改造秒杀业务主要体现在redis预读库存，然后用消息中间件去扣库存）
压测秒杀接口 再压测获取秒杀结果接口

> 可以搞一个reset接口，每次在压测前还原库存

5000线程*10个循环，总共50000个请求

用户token文件5000个用户token.txt，秒杀一个商品，然后测试脚本文件miaosha.jmx上传到服务器，然后用jmeter进行测试，

top看负载，java-秒杀，java-jmeter，redis-缓存读写

```
QPS 1300	load 25	-- 第一次热身
QPS 2114	load 5 	-- 正式跑，前端做的事情很少，不用读动态数据
```

4核cpu快到性能极限，mysql redis rabbitMQ jmeter web程序在同一台服务器

真实情况mysql一台服务器，redis在一台服务器，rabbitMQ在一台服务器，web程序在一台服务器会准确一点

3.Nginx水平扩展，压测 

利用nginx代理，将请求分发给多台服务器

## 第七章 安全优化

![image-20210329002403224](C:\Users\94307\OneDrive - zju.edu.cn\learnbm\JAVA\学习笔记\image-20210329002403224.png)

**秒杀开始之前，先去请求接口获取秒杀地址**

**错峰请求秒杀接口**
**请求完了详情接口之后，接着去请求获取验证码的接口**
**在点击秒杀获取路径的时候，去验证验证码**

**1.隐藏秒杀接口地址**

> 请求秒杀接口之前先去请求秒杀路径，请求秒杀路径时要进行数学验证码
>
> 秒杀地址是要从服务端获取动态拼接，进行秒杀之前要验证秒杀地址是否准确

改造getmiaoshapath的接口，动态生成秒杀地址，在redis中存放秒杀路径的key和value，key是前缀（类名+mp）+ 用户id + 商品id + uuid(每次随机生成)

秒杀接口加上PathVariable参数，添加秒杀地址的参数，同时需要验证秒杀地址

客户端轮询的时间可以适当设置长一点，例如200ms防止服务器压力过大。

**2.数学公式验证码, 生成数学计算题，SriptEngine**

**防止机器人刷单，防止用户高频点击，将用户的请求分散到了做题时间之内削减并发量**

写一个生成图片验证码的接口，bufferedrimage

用随机数和一个操作数组来生成计算公式

计算用SriptEngine实现，调用js的引擎，引用其中的eval方法

用户输入的验证码通过requestParam注入到获取秒杀地址的接口中

**12306验证码那么复杂就是因为需要限流**

```java
public BufferedImage createVerifyCodeImage(long userId, long goodsId) {
	int width = 80;
	int height = 32;
	//create the image
	BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
	Graphics g = image.getGraphics();
	// set the background color
	g.setColor(new Color(0xDCDCDC));
	g.fillRect(0, 0, width, height);
	// draw the border
	g.setColor(Color.black);
	g.drawRect(0, 0, width - 1, height - 1);
	// create a random instance to generate the codes
	Random rdm = new Random();
	// make some confusion
	for (int i = 0; i < 50; i++) {
		int x = rdm.nextInt(width);
		int y = rdm.nextInt(height);
		g.drawOval(x, y, 0, 0);
	}
	// generate a random code
	String verifyCode = createVerifyCode();
	g.setColor(new Color(0, 100, 0));
	g.setFont(new Font("Candara", Font.BOLD, 24));
	g.drawString(verifyCode, 8, 24);
	g.dispose();
	//把验证码存到redis中
	int rnd = calc(verifyCode);
	redisService.set(MiaoshaKey.verify_code, userId+","+goodsId, rnd);
	//输出图片	
	return image;
}

BufferedImage image = miaoshaService.createVerifyCodeImage(user.getId(), goodsId);
response.setContentType("image/jpeg");
OutputStream out = response.getOutputStream();
ImageIO.write(image, "jpeg", out);
out.close();
return null;
```



<div class="row">
				<div class="form-inline">  
					<img id="verifyCodeImg" width="80" height="32" style="display:none" onclick="refreshVerifyCode()"/>
					<input class="form-control" type="text" name="verifyCode" id="verifyCode" style="display:none" />
				    <button class="btn btn-primary" id="buyButton" onclick="doMiaosha()">立即秒杀</button>
				    <input type="hidden" name="goodsId"  id="goodsId" />
				</div>
			</div>
**3.接口防刷，针对需要用户登录的接口做限流**

前端是不可以限流的，http是明文传输的

比如：限制10秒以内对某个接口最多请求10次，还是用redis
以秒杀接口为例，可以把用户和限流用拦截器来做

>  放到缓存中做，在缓存中设置一个表示操作次数的数据，设计一个有效期，例如60s，如果在60s内重复点击，那么这个数就加1，超过10次就返回操作失败，到达下一个60s就再从0开始计时。

这是改造前的，放在获取秒杀地址方法里，需要在redis中存放一个key

```java
// 查询访问的次数
String uri = request.getRequestURI();
String key = uri + "_" + user.getId();
Integer count = redisService.get(AccessKey.access, key, Integer.class);
if (count == null){
	redisService.set(AccessKey.access, key, 1);
} else if(count < 5){
	redisService.incr(AccessKey.access, key);
} else {
    return Result.error(CodeMsg.ACCESS_LIMIT_REACHED);
}
```

如果有多个方法都需要限流，可以使用拦截器，在每个方法前使用如下注解即可

@AccessLimit(second = 5, macCount = 5, needLogin = true)

在拦截器中完善代码

ThreadLocal关键字：多线程的时候保证线程安全的访问方式，threadlocal是和当前线程绑定的，往threadlocal放东西释放到当前线程来，不会存在线程冲突问题。

**4.回仓：30分钟不支付订单自动取消**
30分钟以后，扫描下秒杀订单，看有哪些还没支付，把订单状态置为已经取消，可秒杀数量+1，redis的秒杀结束的标志位还原，内存的数量还原
不演示了

**补充：为什么要做秒杀地址的隐藏？**

课程中仅仅是通过动态生成秒杀url+数学验证码+防刷限流的方式

而在实际开发中，有一种更为有效的实现方式，在活动开始的时候，通过后台，重新设置一个url，客户端拿到后直接跳转。这样可以防止恶意用户提前抓取网页，对网页进行分析，然后写出刷接口的机器人。活动开始之前，恶意用户就算分析了网页写了刷接口的程序也没有用，因为那个页面不是真正的秒杀页面

**有哪些常用的接口限流防刷的实现方式？**

常见的限流算法：
 最常用限流算法的就是使用**令牌桶**或者**漏斗桶算法**
 常见的实现方式
 (1)在网关上做限流。比如在 nginx上写ua脚本来实现
 (2)在应用上做单机限流。使用诸如基于 Guava的 Rate Limiter令牌桶的方式。
 (3)在应用上做分布式限流。比如 radisson提供了个基于 redis的 Rate Limiter:
https://github.com/redisson/redisson/wiki/6.-distributed-objects#612-ratelimiter
 (4)如果是 Spring Cloud项目，可用的就更多了，比如 Spring Cloud Gateway, Sentinel等等。



# 第八章 服务器优化

## Tomcat优化

**内存优化**

**并发优化**

**APR优化**



# 课程总结

## 第一章 项目框架搭建

1. SpringBoot 环境搭建

2. 集成thymeleaf，Result结果封装

3. 集成Mybatis+Druid，全部用java文件写注解
4. 集成Jedis+Redis安装+通用缓存Key封装

## 第二章 实现登录功能

1. 数据库设计

2. 明文密码两次MD5处理

3. JSR303参数校验（前端只是有消息，后端是防止恶意用户）+全局异常处理器

4. 分布式Session

   防止用户的前后两次请求落在不同的服务器上

## 第三章 实现秒杀功能

1. 数据库设计
2. 商品列表页
3. 商品详情页
4. 订单详情页

## 第四章 JMeter压测

1. JMeter入门
2. 自定义多变量模拟多用户

## 第五章 页面优化技术

1. 页面缓存+URL缓存+对象缓存
2. 页面静态化+前后端分离
3. 静态资源优化
4. CDN优化

## 第六章 接口优化

1. redis预减库存减少数据库访问

2. 内存标记减少redis访问

3. rabbitMQ队列缓冲，异步下单，增强用户体验

   扩展的基础是做了缓存优化

4. 访问Nginx水平扩展

## 第七章 安全优化

1. 秒杀接口地址隐藏
2. 数学公式验证码
3. 接口防刷

## 秒杀常见问题

### **1.redis事务处理**

我们可以使用redis中的监听（watch）方法，去监听库存数量，一旦库存数量在其他客户端发生改变，后续操作则会失败。

### **2. redis分布式锁**

分布式锁确保只有一个线程会操作库存

- 加锁（占个位置，后续的进不来）：setnx命令: 只在键key不存在的情况下，将键key的值设置为value 。若键key已经存在， 则不做任何动作。
- 解锁（用完了，就把位置让出来）：del（key）
- 锁超时（万一中间出现点意外，没有解锁，过几秒会自动释放）expire（key，30）

**单库高并发脏数据处理**

悲观锁

即使Redis是单线程的，但是在多线程的情况下，可能会出现脏读这样的问题。比如，线程A从Redis读到key X的值=1，线程B也读到1，但是线程A读到之后进行计算将其改为2，线程B的值还是1，还在用拿到的1进行业务计算，这样就会出问题。通过setnx设置一把锁，每个线程过来，只有获取了锁才能继续操作，否则就重试，获得锁的线程执行自己的计算操作，执行完之后，删掉锁，这样其他的线程再进来执行的时候，数据就是最新的。不会出现脏读的问题。

乐观锁 

redis中可以使用watch命令会监视给定的key，当exec时候如果监视的key从调用watch后发生过变化，则整个事务会失败。也可以调用watch多次监视多个key。这样就可以对指定的key加乐观锁了。注意watch的key是对整个连接有效的，事务也一样。如果连接断开，监视和事务都会被自动清除。当然了exec，discard，unwatch命令都会清除连接中的所有监视。

Redis事务
Redis中的事务(transaction)是一组命令的集合。事务同命令一样都是Redis最小的执行单位，一个事务中的命令要么都执行，要么都不执行。Redis事务的实现需要用到 MULTI 和 EXEC 两个命令，事务开始的时候先向Redis服务器发送 MULTI 命令，然后依次发送需要在本次事务中处理的命令，最后再发送 EXEC 命令表示事务命令结束。Redis的事务是下面4个命令来实现 

1.multi，开启Redis的事务，置客户端为事务态。
2.exec，提交事务，执行从multi到此命令前的命令队列，置客户端为非事务态。
3.discard，取消事务，置客户端为非事务态。
4.watch,监视键值对，作用时如果事务提交exec时发现监视的监视对发生变化，事务将被取消。

### **3.redis队列（rpoplpush的安全队列）**

把每一件商品都lpush到redis队列中，利用lpop从队列中去取

### 4.  如何保证不卖超

有两种情况可能会导致卖超：（1）一个用户同时发出了多个请求，如果库存足够，没加限制，用户就可以下多个订单。（2）减库存的sql上没有加库存数量的判断，并发的时候也会导致把库存减成负数。

我们的解决办法：

对于（1）：前端加验证码，防止用户同时发出多个请求，在后端的miaosha_order表中，对user_id和goods_id加唯一索引，确保一个用户对一个商品绝对不会生成两个订单。

对于（2）：我们的减库存的sql上应该加上库存数量的判断：                          

数据库更新记录的时候会加锁，实际上是串行的执行update的，因此绝对不会卖超！

### 5.  Redis中的库存如何与DB中的库存保持一致？

Redis中的数量不是库存，它的作用仅仅时候只是为了阻挡多余的请求透传到db，起到一个保护DB的作用。因为秒杀商品的数量是有限的，比如只有10个，让1万个请求去访问DB是没有意义的，因为最多只有10个请求会下单成功，剩余的9990个请求都是无效的，是可以不用去访问db而直接失败的。

**可以通过消息队列，去异步扣减库存**

因此，这是一个伪问题，我们是不需要保持一致的。

### 6.  Redis预减成功，DB扣减库存失败怎么办？即少卖

两大类情况可导致redis预减成功而DB扣减失败：

（1）   如果一个用户发出了多个请求（不管何种手段），而这些所有的请求比所有其他用的请求都更快的到达了服务器，这个时候如果库存足够，就会出现redis预减多次，而只能下单成功一次（前提是：这个用户的多个请求比网站的其他用户的请求都更快的到达服务器，这在网络环境不可知的情况下，基本不可能）

（2）   还有就是在生成订单的过程中发生了不可预料的异常，也会导致redis扣减成功，而db扣减失败（如果是DB出现了异常，可能所有的订单都无法生成，但是只要存在redis预减，活动就可以正常结束）

因此，在初始化的时候，redis中的数量可以多于db的库存数量。

出现这种情况的后果是什么？

（1）   对用户而言，秒杀不中是正常现象，秒杀中才是意外，单个用户能否秒杀中本来就是小概率事件，出现这种情况对用户而言是没有任何影响的。

（2）   对商户而言，本来就是为了做活动拉流量拉人气的，卖不完还可以省一部分费用，但是活动还是正常参与了，也是没有任何影响

（3）   对网站而言，网站最重要的是用户体验，只要网站不崩，用户不骂娘，对网站也没有任何影响。

所以，卖不完是完全允许的，但是卖超是绝对不允许的！卖超的这部分钱商家是不会出的，需要网站自己来出。

### 7.  为什么Redis中的数量会减成负数？

假如redis中的数量是1，这个时候同时过来100个请求，大家一起去执行decr,数量就会减成-99，这是正常的。

### 8.  为什么要单独维护一个秒杀结束的标志？

（1）   前面也提过，所有的秒杀相关的接口都要加上活动是否结束的标志，如果结束就直接返回了，包括轮询的接口，防止一直轮询没法结束。

（2）   管理后台也可以手动的更改这个标志，防止出现活动开始以后就没法结束这种意外的发生。

### 9.  如果用户秒杀成成功了，但是没有付款怎么办？

一般网站都会有下单30分钟不支付订单自动取消这样的操作，此时就需要把库存再加回去，因此又叫回仓。

可以在创建订单以后，把订单写入到延迟队列里面（RabbitMQ、RocketMQ都支持），如果在有效期之内用户做了付款，则从队列删除，否则等延迟队列数据出队的时候，再去查询数据库订单的状态，如果是未支付则需要回仓。回仓无非就是重置redis和mysql的数据，包括一些秒杀结束的状态等等。

### 10.  为什么要做隐藏秒杀接口地址？

（1）   html是可以被右键->查看源代码，如果秒杀地址写死在源文件中，是很容易就被恶意用户拿到的，就可以被机器人利用来刷接口。

（2）   通过一个接口来返回秒杀地址的好处是，可以在活动临近开始的时候，服务端可以把地址换掉，这样就算恶意用户提前拿到了地址，但是拿到的也是一个不可用的地址。

（3）   服务端可以通过管理后台来随时修改接口的地址。